/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.16.0.0 (NJsonSchema v9.10.39.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import * as moment from 'moment';

export class UsersServiceProxy {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : 'http:///api';
  }

  /**
   * Find users
   * @name (optional) username or fullname
   * @role (optional) role
   * @pageIndex (optional) page index, default value is 0
   * @itemPerPageCount (optional) request item, default value is 10
   * @sortBy sort field
   * @asc sort order
   * @return Return information of selected users
   */
  find(
    name: string | null | undefined,
    role: string | null | undefined,
    pageIndex: number | null | undefined,
    itemPerPageCount: number | null | undefined,
    sortBy: string,
    asc: boolean,
  ): Promise<FindAllUsersResultDto> {
    let url_ = this.baseUrl + '/users/find?';
    if (name !== undefined)
      url_ += 'name=' + encodeURIComponent('' + name) + '&';
    if (role !== undefined)
      url_ += 'role=' + encodeURIComponent('' + role) + '&';
    if (pageIndex !== undefined)
      url_ += 'pageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (itemPerPageCount !== undefined)
      url_ +=
        'itemPerPageCount=' + encodeURIComponent('' + itemPerPageCount) + '&';
    if (sortBy === undefined || sortBy === null)
      throw new Error(
        "The parameter 'sortBy' must be defined and cannot be null.",
      );
    else url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (asc === undefined || asc === null)
      throw new Error(
        "The parameter 'asc' must be defined and cannot be null.",
      );
    else url_ += 'asc=' + encodeURIComponent('' + asc) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFind(_response);
    });
  }

  protected processFind(response: Response): Promise<FindAllUsersResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? FindAllUsersResultDto.fromJS(resultData200)
          : new FindAllUsersResultDto();
        return result200;
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FindAllUsersResultDto>(<any>null);
  }

  /**
   * Find an user by username
   * @return Return information of selected users
   */
  findByUsername(username: string): Promise<FindUserResultDto> {
    let url_ = this.baseUrl + '/users/findByUsername/{username}';
    if (username === undefined || username === null)
      throw new Error("The parameter 'username' must be defined.");
    url_ = url_.replace('{username}', encodeURIComponent('' + username));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindByUsername(_response);
    });
  }

  protected processFindByUsername(
    response: Response,
  ): Promise<FindUserResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? FindUserResultDto.fromJS(resultData200)
          : new FindUserResultDto();
        return result200;
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FindUserResultDto>(<any>null);
  }

  /**
   * Find an user by email
   * @return Return information of selected users
   */
  findByEmail(email: string): Promise<FindUserResultDto> {
    let url_ = this.baseUrl + '/users/findByEmail/{email}';
    if (email === undefined || email === null)
      throw new Error("The parameter 'email' must be defined.");
    url_ = url_.replace('{email}', encodeURIComponent('' + email));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindByEmail(_response);
    });
  }

  protected processFindByEmail(response: Response): Promise<FindUserResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? FindUserResultDto.fromJS(resultData200)
          : new FindUserResultDto();
        return result200;
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FindUserResultDto>(<any>null);
  }

  /**
   * Create user
   * @return The user has been successfully created.
   */
  create(
    createUserInputDto: CreateUserInputDto,
  ): Promise<FindAllUsersDetailDto> {
    let url_ = this.baseUrl + '/users/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(createUserInputDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreate(_response);
    });
  }

  protected processCreate(response: Response): Promise<FindAllUsersDetailDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        let result201: any = null;
        let resultData201 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = resultData201
          ? FindAllUsersDetailDto.fromJS(resultData201)
          : new FindAllUsersDetailDto();
        return result201;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 422) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FindAllUsersDetailDto>(<any>null);
  }

  /**
   * Update user
   * @return The user has been successfully updated.
   */
  update(updateUserInputDto: UpdateUserInputDto): Promise<void> {
    let url_ = this.baseUrl + '/users/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(updateUserInputDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdate(_response);
    });
  }

  protected processUpdate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        return;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 422) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Deactivate user
   * @return The user has been successfully deactivated.
   */
  deactivate(username: string): Promise<void> {
    let url_ = this.baseUrl + '/users/{username}/deactivate';
    if (username === undefined || username === null)
      throw new Error("The parameter 'username' must be defined.");
    url_ = url_.replace('{username}', encodeURIComponent('' + username));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'PATCH',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeactivate(_response);
    });
  }

  protected processDeactivate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        return;
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Unlock user
   * @return The profile has been successfully unlocked.
   */
  unlock(username: string): Promise<void> {
    let url_ = this.baseUrl + '/users/{username}/unlock';
    if (username === undefined || username === null)
      throw new Error("The parameter 'username' must be defined.");
    url_ = url_.replace('{username}', encodeURIComponent('' + username));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'PATCH',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUnlock(_response);
    });
  }

  protected processUnlock(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        return;
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class AuthServiceProxy {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : 'http:///api';
  }

  /**
   * Login with username & password
   * @return Login successfully
   */
  login(loginUserInputDto: LoginUserInputDto): Promise<TokenInfoDto> {
    let url_ = this.baseUrl + '/auth/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(loginUserInputDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLogin(_response);
    });
  }

  protected processLogin(response: Response): Promise<TokenInfoDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        let result201: any = null;
        let resultData201 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = resultData201
          ? TokenInfoDto.fromJS(resultData201)
          : new TokenInfoDto();
        return result201;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<TokenInfoDto>(<any>null);
  }

  /**
   * Get new token
   * @return Refresh successfully
   */
  refreshToken(refreshTokenDto: RefreshTokenDto): Promise<TokenInfoDto> {
    let url_ = this.baseUrl + '/auth/refreshToken';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(refreshTokenDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRefreshToken(_response);
    });
  }

  protected processRefreshToken(response: Response): Promise<TokenInfoDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        let result201: any = null;
        let resultData201 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = resultData201
          ? TokenInfoDto.fromJS(resultData201)
          : new TokenInfoDto();
        return result201;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<TokenInfoDto>(<any>null);
  }

  /**
   * Google Authentication
   */
  loginWithGoogle(): Promise<void> {
    let url_ = this.baseUrl + '/auth/loginWithGoogle';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLoginWithGoogle(_response);
    });
  }

  protected processLoginWithGoogle(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  loginWithGoogleCallback(): Promise<void> {
    let url_ = this.baseUrl + '/auth/loginWithGoogleCallback';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLoginWithGoogleCallback(_response);
    });
  }

  protected processLoginWithGoogleCallback(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Facebook Authentication
   */
  loginWithFacebook(): Promise<void> {
    let url_ = this.baseUrl + '/auth/loginWithFacebook';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLoginWithFacebook(_response);
    });
  }

  protected processLoginWithFacebook(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  loginWithFacebookCallback(): Promise<void> {
    let url_ = this.baseUrl + '/auth/loginWithFacebookCallback';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLoginWithFacebookCallback(_response);
    });
  }

  protected processLoginWithFacebookCallback(
    response: Response,
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Register user
   * @return The user has been successfully created.
   */
  register(registerUserInputDto: RegisterUserInputDto): Promise<void> {
    let url_ = this.baseUrl + '/auth/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(registerUserInputDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRegister(_response);
    });
  }

  protected processRegister(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        return;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 422) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ProfilesServiceProxy {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : 'http:///api';
  }

  /**
   * Get user profile
   * @return Return user profile
   */
  get(id: string): Promise<GetProfileResultDto> {
    let url_ = this.baseUrl + '/profiles/get/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGet(_response);
    });
  }

  protected processGet(response: Response): Promise<GetProfileResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? GetProfileResultDto.fromJS(resultData200)
          : new GetProfileResultDto();
        return result200;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<GetProfileResultDto>(<any>null);
  }

  /**
   * Update user profile
   * @return Profile has been successfully updated
   */
  update(updateProfileInputDto: UpdateProfileInputDto): Promise<void> {
    let url_ = this.baseUrl + '/profiles/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(updateProfileInputDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdate(_response);
    });
  }

  protected processUpdate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        return;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Upload profile picture
   * @return Upload profile picture success
   */
  uploadProfilePicture(): Promise<string> {
    let url_ = this.baseUrl + '/profiles/uploadProfilePicture';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUploadProfilePicture(_response);
    });
  }

  protected processUploadProfilePicture(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<string>(<any>null);
  }
}

export class RolesServiceProxy {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : 'http:///api';
  }

  /**
   * Find roles
   * @name (optional) role name
   * @permissions (optional) role permissions
   * @pageIndex page index
   * @itemPerPageCount page size
   * @sortBy sort field
   * @asc sort order
   * @return Return information of selected roles
   */
  find(
    name: string | null | undefined,
    permissions: any[] | null | undefined,
    pageIndex: number,
    itemPerPageCount: number,
    sortBy: string,
    asc: boolean,
  ): Promise<FindAllRolesResultDto> {
    let url_ = this.baseUrl + '/roles/find?';
    if (name !== undefined)
      url_ += 'name=' + encodeURIComponent('' + name) + '&';
    if (permissions !== undefined)
      permissions &&
        permissions.forEach(item => {
          url_ += 'permissions=' + encodeURIComponent('' + item) + '&';
        });
    if (pageIndex === undefined || pageIndex === null)
      throw new Error(
        "The parameter 'pageIndex' must be defined and cannot be null.",
      );
    else url_ += 'pageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (itemPerPageCount === undefined || itemPerPageCount === null)
      throw new Error(
        "The parameter 'itemPerPageCount' must be defined and cannot be null.",
      );
    else
      url_ +=
        'itemPerPageCount=' + encodeURIComponent('' + itemPerPageCount) + '&';
    if (sortBy === undefined || sortBy === null)
      throw new Error(
        "The parameter 'sortBy' must be defined and cannot be null.",
      );
    else url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (asc === undefined || asc === null)
      throw new Error(
        "The parameter 'asc' must be defined and cannot be null.",
      );
    else url_ += 'asc=' + encodeURIComponent('' + asc) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFind(_response);
    });
  }

  protected processFind(response: Response): Promise<FindAllRolesResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? FindAllRolesResultDto.fromJS(resultData200)
          : new FindAllRolesResultDto();
        return result200;
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FindAllRolesResultDto>(<any>null);
  }

  /**
   * Create role
   * @return Return information of new created role
   */
  create(
    createRoleInputDto: CreateRoleInputDto,
  ): Promise<FindAllRolesDetailDto> {
    let url_ = this.baseUrl + '/roles/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(createRoleInputDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreate(_response);
    });
  }

  protected processCreate(response: Response): Promise<FindAllRolesDetailDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        let result201: any = null;
        let resultData201 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = resultData201
          ? FindAllRolesDetailDto.fromJS(resultData201)
          : new FindAllRolesDetailDto();
        return result201;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 422) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FindAllRolesDetailDto>(<any>null);
  }

  /**
   * Update role
   * @return Update Role Success
   */
  update(
    updateRoleInputDto: UpdateRoleInputDto,
  ): Promise<FindAllRolesDetailDto> {
    let url_ = this.baseUrl + '/roles/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(updateRoleInputDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdate(_response);
    });
  }

  protected processUpdate(response: Response): Promise<FindAllRolesDetailDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? FindAllRolesDetailDto.fromJS(resultData200)
          : new FindAllRolesDetailDto();
        return result200;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FindAllRolesDetailDto>(<any>null);
  }

  /**
   * Delete role
   * @return Delete Success
   */
  delete(deleteRoleDto: DeleteRoleDto): Promise<FindAllRolesDetailDto> {
    let url_ = this.baseUrl + '/roles/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(deleteRoleDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'DELETE',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDelete(_response);
    });
  }

  protected processDelete(response: Response): Promise<FindAllRolesDetailDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? FindAllRolesDetailDto.fromJS(resultData200)
          : new FindAllRolesDetailDto();
        return result200;
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<FindAllRolesDetailDto>(<any>null);
  }
}

export class AppSettingsServiceProxy {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : 'http:///api';
  }

  /**
   * Get App Settings
   * @return Return app settings
   */
  get(): Promise<any> {
    let url_ = this.baseUrl + '/appSettings/get';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGet(_response);
    });
  }

  protected processGet(response: Response): Promise<any> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200) {
          result200 = {};
          for (let key in resultData200) {
            if (resultData200.hasOwnProperty(key))
              result200[key] = resultData200[key];
          }
        }
        return result200;
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<any>(<any>null);
  }
}

export class CompanyServiceProxy {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : 'http:///api';
  }

  /**
   * Create company
   * @return The company has been successfully created.
   */
  create(createCompanyInputDto: CreateCompanyInputDto): Promise<void> {
    let url_ = this.baseUrl + '/company/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(createCompanyInputDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreate(_response);
    });
  }

  protected processCreate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        return;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 422) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Update company infomation
   * @return Update company infomation Success
   */
  update(updateCompanyInputDto: UpdateCompanyInputDto): Promise<void> {
    let url_ = this.baseUrl + '/company/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(updateCompanyInputDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdate(_response);
    });
  }

  protected processUpdate(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        return;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Find company
   * @return Return information of company
   */
  find(): Promise<any> {
    let url_ = this.baseUrl + '/company/find';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFind(_response);
    });
  }

  protected processFind(response: Response): Promise<any> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<any>(<any>null);
  }

  /**
   * Upload Image
   * @return Upload Successful
   */
  upload(): Promise<string> {
    let url_ = this.baseUrl + '/company/upload';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpload(_response);
    });
  }

  protected processUpload(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<string>(<any>null);
  }

  /**
   * Upload Image
   * @return Upload Successful
   */
  getCompanyLogo(): Promise<string> {
    let url_ = this.baseUrl + '/company/getCompanyLogo';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetCompanyLogo(_response);
    });
  }

  protected processGetCompanyLogo(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<string>(<any>null);
  }
}

export class UploadImagesServiceProxy {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : 'http:///api';
  }

  /**
   * Upload images
   * @return Upload images success
   */
  upload(): Promise<GetUploadedImagesDetailDto> {
    let url_ = this.baseUrl + '/uploadImages/upload';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpload(_response);
    });
  }

  protected processUpload(
    response: Response,
  ): Promise<GetUploadedImagesDetailDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? GetUploadedImagesDetailDto.fromJS(resultData200)
          : new GetUploadedImagesDetailDto();
        return result200;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 401) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<GetUploadedImagesDetailDto>(<any>null);
  }

  /**
   * Get user uploaded images
   * @return Return user uploaded images
   */
  get(search: string, id: string): Promise<GetUploadedImagesResultDto> {
    let url_ = this.baseUrl + '/uploadImages/get/{id}?';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (search === undefined || search === null)
      throw new Error(
        "The parameter 'search' must be defined and cannot be null.",
      );
    else url_ += 'search=' + encodeURIComponent('' + search) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGet(_response);
    });
  }

  protected processGet(
    response: Response,
  ): Promise<GetUploadedImagesResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? GetUploadedImagesResultDto.fromJS(resultData200)
          : new GetUploadedImagesResultDto();
        return result200;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<GetUploadedImagesResultDto>(<any>null);
  }

  /**
   * Upload image filename
   * @return Upload image filename
   */
  updateFilename(updateFilenameDto: UpdateFilenameDto): Promise<void> {
    let url_ = this.baseUrl + '/uploadImages/updateFilename';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(updateFilenameDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateFilename(_response);
    });
  }

  protected processUpdateFilename(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        return;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete image
   * @return Delete image success
   */
  deleteImage(imageId: string): Promise<void> {
    let url_ = this.baseUrl + '/uploadImages/deleteImage/{imageId}';
    if (imageId === undefined || imageId === null)
      throw new Error("The parameter 'imageId' must be defined.");
    url_ = url_.replace('{imageId}', encodeURIComponent('' + imageId));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'DELETE',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteImage(_response);
    });
  }

  protected processDeleteImage(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        return;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Create a new album
   * @return Create album success
   */
  createAlbum(createAlbumDto: CreateAlbumDto): Promise<void> {
    let url_ = this.baseUrl + '/uploadImages/createAlbum';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(createAlbumDto);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: new Headers({
        'Content-Type': 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateAlbum(_response);
    });
  }

  protected processCreateAlbum(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        return;
      });
    } else if (status === 400) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class BlogServiceProxy {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
      this.http = http ? http : <any>window;
      this.baseUrl = baseUrl ? baseUrl : "http:///api";
  }

  /**
   * Add new post
   * @return A new post has been successfully created.
   */
  newpost(createBlogInputDto: CreateBlogInputDto): Promise<void> {
      let url_ = this.baseUrl + "/blog/newpost";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(createBlogInputDto);

      let options_ = <RequestInit>{
          body: content_,
          method: "POST",
          headers: new Headers({
              "Content-Type": "application/json", 
          })
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processNewpost(_response);
      });
  }

  protected processNewpost(response: Response): Promise<void> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
      if (status === 201) {
          return response.text().then((_responseText) => {
          return;
          });
      } else if (status === 400) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 422) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<void>(<any>null);
  }

  /**
   * Edit Post
   * @return Post has been successfully edited.
   */
  edit(id: string, updateBlogDetailDto: UpdateBlogDetailDto): Promise<UpdateBlogDetailDto> {
      let url_ = this.baseUrl + "/blog/edit/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(updateBlogDetailDto);

      let options_ = <RequestInit>{
          body: content_,
          method: "PUT",
          headers: new Headers({
              "Content-Type": "application/json", 
              "Accept": "application/json"
          })
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processEdit(_response);
      });
  }

  protected processEdit(response: Response): Promise<UpdateBlogDetailDto> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
      if (status === 201) {
          return response.text().then((_responseText) => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = resultData201 ? UpdateBlogDetailDto.fromJS(resultData201) : new UpdateBlogDetailDto();
          return result201;
          });
      } else if (status === 400) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 422) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<UpdateBlogDetailDto>(<any>null);
  }

  /**
   * Delete Post
   * @return Post has been successfully deleted.
   */
  delete(id: string): Promise<void> {
      let url_ = this.baseUrl + "/blog/delete/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
      url_ = url_.replace(/[?&]$/, "");

      let options_ = <RequestInit>{
          method: "PUT",
          headers: new Headers({
              "Content-Type": "application/json", 
          })
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processDelete(_response);
      });
  }

  protected processDelete(response: Response): Promise<void> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
      if (status === 201) {
          return response.text().then((_responseText) => {
          return;
          });
      } else if (status === 400) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 422) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<void>(<any>null);
  }

  /**
   * Deactivate Post
   * @return Post has been successfully Deactivated.
   */
  deactivatePost(id: string): Promise<void> {
      let url_ = this.baseUrl + "/blog/deactivate-post/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
      url_ = url_.replace(/[?&]$/, "");

      let options_ = <RequestInit>{
          method: "PATCH",
          headers: new Headers({
              "Content-Type": "application/json", 
          })
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processDeactivatePost(_response);
      });
  }

  protected processDeactivatePost(response: Response): Promise<void> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
      if (status === 201) {
          return response.text().then((_responseText) => {
          return;
          });
      } else if (status === 400) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 422) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<void>(<any>null);
  }

  /**
   * Activate Post
   * @return Post has been successfully Activated.
   */
  activatePost(id: string): Promise<void> {
      let url_ = this.baseUrl + "/blog/activate-post/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
      url_ = url_.replace(/[?&]$/, "");

      let options_ = <RequestInit>{
          method: "PATCH",
          headers: new Headers({
              "Content-Type": "application/json", 
          })
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processActivatePost(_response);
      });
  }

  protected processActivatePost(response: Response): Promise<void> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
      if (status === 201) {
          return response.text().then((_responseText) => {
          return;
          });
      } else if (status === 400) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 422) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<void>(<any>null);
  }

  /**
   * Get All Post
   * @return Posts has been fetched successfully.
   */
  getpost(): Promise<FindAllBlogPostsDto> {
      let url_ = this.baseUrl + "/blog/getpost";
      url_ = url_.replace(/[?&]$/, "");

      let options_ = <RequestInit>{
          method: "GET",
          headers: new Headers({
              "Content-Type": "application/json", 
              "Accept": "application/json"
          })
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processGetpost(_response);
      });
  }

  protected processGetpost(response: Response): Promise<FindAllBlogPostsDto> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FindAllBlogPostsDto.fromJS(resultData200) : new FindAllBlogPostsDto();
          return result200;
          });
      } else if (status === 400) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 422) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<FindAllBlogPostsDto>(<any>null);
  }

  /**
   * Get all post title
   * @return Post title has been successfully fetched.
   */
  getAllPostTitle(): Promise<any[]> {
      let url_ = this.baseUrl + "/blog/getAllPostTitle";
      url_ = url_.replace(/[?&]$/, "");

      let options_ = <RequestInit>{
          method: "GET",
          headers: new Headers({
              "Content-Type": "application/json", 
              "Accept": "application/json"
          })
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processGetAllPostTitle(_response);
      });
  }

  protected processGetAllPostTitle(response: Response): Promise<any[]> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (resultData200 && resultData200.constructor === Array) {
              result200 = [];
              for (let item of resultData200)
                  result200.push(item);
          }
          return result200;
          });
      } else if (status === 400) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 422) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<any[]>(<any>null);
  }

  /**
   * findPostByTitle
   * @return Post title has been successfully fetched.
   */
  findPostByTitle(searchInputDto: SearchInputDto): Promise<FindAllBlogPostsDto> {
      let url_ = this.baseUrl + "/blog/findPostByTitle";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(searchInputDto);

      let options_ = <RequestInit>{
          body: content_,
          method: "POST",
          headers: new Headers({
              "Content-Type": "application/json", 
              "Accept": "application/json"
          })
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processFindPostByTitle(_response);
      });
  }

  protected processFindPostByTitle(response: Response): Promise<FindAllBlogPostsDto> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
      if (status === 201) {
          return response.text().then((_responseText) => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = resultData201 ? FindAllBlogPostsDto.fromJS(resultData201) : new FindAllBlogPostsDto();
          return result201;
          });
      } else if (status === 400) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 422) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<FindAllBlogPostsDto>(<any>null);
  }

  /**
   * findPostByDate
   * @return Post title has been successfully fetched.
   */
  findPostByDate(dateRangeInputDto: DateRangeInputDto): Promise<FindAllBlogPostsDto> {
      let url_ = this.baseUrl + "/blog/findPostByDate";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(dateRangeInputDto);

      let options_ = <RequestInit>{
          body: content_,
          method: "POST",
          headers: new Headers({
              "Content-Type": "application/json", 
              "Accept": "application/json"
          })
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processFindPostByDate(_response);
      });
  }

  protected processFindPostByDate(response: Response): Promise<FindAllBlogPostsDto> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
      if (status === 201) {
          return response.text().then((_responseText) => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = resultData201 ? FindAllBlogPostsDto.fromJS(resultData201) : new FindAllBlogPostsDto();
          return result201;
          });
      } else if (status === 400) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 422) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<FindAllBlogPostsDto>(<any>null);
  }

  /**
   * getActivePost
   * @return Posts has been fetched successfully.
   */
  getActivePost(): Promise<FindAllBlogPostsDto> {
      let url_ = this.baseUrl + "/blog/getActivePost";
      url_ = url_.replace(/[?&]$/, "");

      let options_ = <RequestInit>{
          method: "GET",
          headers: new Headers({
              "Content-Type": "application/json", 
              "Accept": "application/json"
          })
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processGetActivePost(_response);
      });
  }

  protected processGetActivePost(response: Response): Promise<FindAllBlogPostsDto> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 ? FindAllBlogPostsDto.fromJS(resultData200) : new FindAllBlogPostsDto();
          return result200;
          });
      } else if (status === 400) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 403) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status === 422) {
          return response.text().then((_responseText) => {
          return throwException("A server error occurred.", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<FindAllBlogPostsDto>(<any>null);
  }
}

export class I18nServiceProxy {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : 'http:///api';
  }

  /**
   * Get Language Translatation
   * @lng language
   * @return Get Language Translatation
   */
  getLanguage(lng: string): Promise<GetLanguageResultDto> {
    let url_ = this.baseUrl + '/i18n/getLanguage?';
    if (lng === undefined || lng === null)
      throw new Error(
        "The parameter 'lng' must be defined and cannot be null.",
      );
    else url_ += 'lng=' + encodeURIComponent('' + lng) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: new Headers({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetLanguage(_response);
    });
  }

  protected processGetLanguage(
    response: Response,
  ): Promise<GetLanguageResultDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v, k) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? GetLanguageResultDto.fromJS(resultData200)
          : new GetLanguageResultDto();
        return result200;
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        return throwException(
          'A server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then(_responseText => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<GetLanguageResultDto>(<any>null);
  }
}

export class FindAllUsersDetailDto implements IFindAllUsersDetailDto {
  /** user id */
  _id!: string;
  /** username */
  username!: string;
  /** first name */
  firstName!: string;
  /** middle name */
  middleName!: string | undefined;
  /** last name */
  lastName!: string;
  /** full name */
  fullName!: string;
  /** email */
  email!: string;
  /** role */
  roles!: any[];
  /** permissions */
  permissions!: any[];
  /** is active */
  isActive!: boolean;

  constructor(data?: IFindAllUsersDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.roles = [];
      this.permissions = [];
    }
  }

  init(data?: any) {
    if (data) {
      this._id = data['_id'];
      this.username = data['username'];
      this.firstName = data['firstName'];
      this.middleName = data['middleName'];
      this.lastName = data['lastName'];
      this.fullName = data['fullName'];
      this.email = data['email'];
      if (data['roles'] && data['roles'].constructor === Array) {
        this.roles = [];
        for (let item of data['roles']) this.roles.push(item);
      }
      if (data['permissions'] && data['permissions'].constructor === Array) {
        this.permissions = [];
        for (let item of data['permissions']) this.permissions.push(item);
      }
      this.isActive = data['isActive'];
    }
  }

  static fromJS(data: any): FindAllUsersDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new FindAllUsersDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['_id'] = this._id;
    data['username'] = this.username;
    data['firstName'] = this.firstName;
    data['middleName'] = this.middleName;
    data['lastName'] = this.lastName;
    data['fullName'] = this.fullName;
    data['email'] = this.email;
    if (this.roles && this.roles.constructor === Array) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item);
    }
    if (this.permissions && this.permissions.constructor === Array) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item);
    }
    data['isActive'] = this.isActive;
    return data;
  }
}

export interface IFindAllUsersDetailDto {
  /** user id */
  _id: string;
  /** username */
  username: string;
  /** first name */
  firstName: string;
  /** middle name */
  middleName: string | undefined;
  /** last name */
  lastName: string;
  /** full name */
  fullName: string;
  /** email */
  email: string;
  /** role */
  roles: any[];
  /** permissions */
  permissions: any[];
  /** is active */
  isActive: boolean;
}

export class FindAllUsersResultDto implements IFindAllUsersResultDto {
  /** data of users */
  data!: FindAllUsersDetailDto[];
  /** total number of users */
  total!: number;

  constructor(data?: IFindAllUsersResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.data = [];
    }
  }

  init(data?: any) {
    if (data) {
      if (data['data'] && data['data'].constructor === Array) {
        this.data = [];
        for (let item of data['data'])
          this.data.push(FindAllUsersDetailDto.fromJS(item));
      }
      this.total = data['total'];
    }
  }

  static fromJS(data: any): FindAllUsersResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new FindAllUsersResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.data && this.data.constructor === Array) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['total'] = this.total;
    return data;
  }
}

export interface IFindAllUsersResultDto {
  /** data of users */
  data: FindAllUsersDetailDto[];
  /** total number of users */
  total: number;
}

export class FindUserResultDto implements IFindUserResultDto {
  username!: string;
  firstName!: string;
  middleName!: string;
  lastName!: string;
  email!: string;

  constructor(data?: IFindUserResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.username = data['username'];
      this.firstName = data['firstName'];
      this.middleName = data['middleName'];
      this.lastName = data['lastName'];
      this.email = data['email'];
    }
  }

  static fromJS(data: any): FindUserResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new FindUserResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['firstName'] = this.firstName;
    data['middleName'] = this.middleName;
    data['lastName'] = this.lastName;
    data['email'] = this.email;
    return data;
  }
}

export interface IFindUserResultDto {
  username: string;
  firstName: string;
  middleName: string;
  lastName: string;
  email: string;
}

export class CreateUserInputDto implements ICreateUserInputDto {
  /** username */
  username!: string;
  /** password */
  password!: string;
  /** first name */
  firstName!: string;
  /** middle name */
  middleName!: string | undefined;
  /** last name */
  lastName!: string;
  /** email */
  email!: string;
  /** roles */
  roles!: any[];
  /** permissions */
  permissions!: any[];

  constructor(data?: ICreateUserInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.roles = [];
      this.permissions = [];
    }
  }

  init(data?: any) {
    if (data) {
      this.username = data['username'];
      this.password = data['password'];
      this.firstName = data['firstName'];
      this.middleName = data['middleName'];
      this.lastName = data['lastName'];
      this.email = data['email'];
      if (data['roles'] && data['roles'].constructor === Array) {
        this.roles = [];
        for (let item of data['roles']) this.roles.push(item);
      }
      if (data['permissions'] && data['permissions'].constructor === Array) {
        this.permissions = [];
        for (let item of data['permissions']) this.permissions.push(item);
      }
    }
  }

  static fromJS(data: any): CreateUserInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['password'] = this.password;
    data['firstName'] = this.firstName;
    data['middleName'] = this.middleName;
    data['lastName'] = this.lastName;
    data['email'] = this.email;
    if (this.roles && this.roles.constructor === Array) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item);
    }
    if (this.permissions && this.permissions.constructor === Array) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item);
    }
    return data;
  }
}

export interface ICreateUserInputDto {
  /** username */
  username: string;
  /** password */
  password: string;
  /** first name */
  firstName: string;
  /** middle name */
  middleName: string | undefined;
  /** last name */
  lastName: string;
  /** email */
  email: string;
  /** roles */
  roles: any[];
  /** permissions */
  permissions: any[];
}

export class UpdateUserInputDto implements IUpdateUserInputDto {
  /** user id */
  _id!: string;
  /** username */
  username!: string;
  /** password */
  password!: string | undefined;
  /** email */
  email!: string;
  /** firstName */
  firstName!: string;
  /** middleName */
  middleName!: string;
  /** lastName */
  lastName!: string;
  /** roles */
  roles!: any[];
  /** permissions */
  permissions!: any[];
  /** is active */
  isActive!: boolean;

  constructor(data?: IUpdateUserInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.roles = [];
      this.permissions = [];
    }
  }

  init(data?: any) {
    if (data) {
      this._id = data['_id'];
      this.username = data['username'];
      this.password = data['password'];
      this.email = data['email'];
      this.firstName = data['firstName'];
      this.middleName = data['middleName'];
      this.lastName = data['lastName'];
      if (data['roles'] && data['roles'].constructor === Array) {
        this.roles = [];
        for (let item of data['roles']) this.roles.push(item);
      }
      if (data['permissions'] && data['permissions'].constructor === Array) {
        this.permissions = [];
        for (let item of data['permissions']) this.permissions.push(item);
      }
      this.isActive = data['isActive'];
    }
  }

  static fromJS(data: any): UpdateUserInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['_id'] = this._id;
    data['username'] = this.username;
    data['password'] = this.password;
    data['email'] = this.email;
    data['firstName'] = this.firstName;
    data['middleName'] = this.middleName;
    data['lastName'] = this.lastName;
    if (this.roles && this.roles.constructor === Array) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item);
    }
    if (this.permissions && this.permissions.constructor === Array) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item);
    }
    data['isActive'] = this.isActive;
    return data;
  }
}

export interface IUpdateUserInputDto {
  /** user id */
  _id: string;
  /** username */
  username: string;
  /** password */
  password: string | undefined;
  /** email */
  email: string;
  /** firstName */
  firstName: string;
  /** middleName */
  middleName: string;
  /** lastName */
  lastName: string;
  /** roles */
  roles: any[];
  /** permissions */
  permissions: any[];
  /** is active */
  isActive: boolean;
}

export class LoginUserInputDto implements ILoginUserInputDto {
  /** user name */
  username!: string;
  /** password */
  password!: string;

  constructor(data?: ILoginUserInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.username = data['username'];
      this.password = data['password'];
    }
  }

  static fromJS(data: any): LoginUserInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new LoginUserInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['password'] = this.password;
    return data;
  }
}

export interface ILoginUserInputDto {
  /** user name */
  username: string;
  /** password */
  password: string;
}

export class TokenInfoDto implements ITokenInfoDto {
  /** token */
  token!: string;
  /** expires in (seconds) */
  expiresIn!: number;

  constructor(data?: ITokenInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.token = data['token'];
      this.expiresIn = data['expiresIn'];
    }
  }

  static fromJS(data: any): TokenInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new TokenInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['token'] = this.token;
    data['expiresIn'] = this.expiresIn;
    return data;
  }
}

export interface ITokenInfoDto {
  /** token */
  token: string;
  /** expires in (seconds) */
  expiresIn: number;
}

export class RefreshTokenDto implements IRefreshTokenDto {
  /** token */
  token!: string;

  constructor(data?: IRefreshTokenDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.token = data['token'];
    }
  }

  static fromJS(data: any): RefreshTokenDto {
    data = typeof data === 'object' ? data : {};
    let result = new RefreshTokenDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['token'] = this.token;
    return data;
  }
}

export interface IRefreshTokenDto {
  /** token */
  token: string;
}

export class RegisterUserInputDto implements IRegisterUserInputDto {
  username!: string;
  password!: string;
  firstName!: string;
  middleName!: string;
  lastName!: string;
  email!: string;

  constructor(data?: IRegisterUserInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.username = data['username'];
      this.password = data['password'];
      this.firstName = data['firstName'];
      this.middleName = data['middleName'];
      this.lastName = data['lastName'];
      this.email = data['email'];
    }
  }

  static fromJS(data: any): RegisterUserInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterUserInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['password'] = this.password;
    data['firstName'] = this.firstName;
    data['middleName'] = this.middleName;
    data['lastName'] = this.lastName;
    data['email'] = this.email;
    return data;
  }
}

export interface IRegisterUserInputDto {
  username: string;
  password: string;
  firstName: string;
  middleName: string;
  lastName: string;
  email: string;
}

export class GetProfileResultDto implements IGetProfileResultDto {
  username!: string;
  firstName!: string;
  middleName!: string;
  lastName!: string;
  email!: string;
  imageSrc!: string;

  constructor(data?: IGetProfileResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.username = data['username'];
      this.firstName = data['firstName'];
      this.middleName = data['middleName'];
      this.lastName = data['lastName'];
      this.email = data['email'];
      this.imageSrc = data['imageSrc'];
    }
  }

  static fromJS(data: any): GetProfileResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetProfileResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['username'] = this.username;
    data['firstName'] = this.firstName;
    data['middleName'] = this.middleName;
    data['lastName'] = this.lastName;
    data['email'] = this.email;
    data['imageSrc'] = this.imageSrc;
    return data;
  }
}

export interface IGetProfileResultDto {
  username: string;
  firstName: string;
  middleName: string;
  lastName: string;
  email: string;
  imageSrc: string;
}

export class UpdateProfileInputDto implements IUpdateProfileInputDto {
  firstName!: string | undefined;
  middleName!: string | undefined;
  lastName!: string | undefined;
  password!: string | undefined;

  constructor(data?: IUpdateProfileInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.firstName = data['firstName'];
      this.middleName = data['middleName'];
      this.lastName = data['lastName'];
      this.password = data['password'];
    }
  }

  static fromJS(data: any): UpdateProfileInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProfileInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['firstName'] = this.firstName;
    data['middleName'] = this.middleName;
    data['lastName'] = this.lastName;
    data['password'] = this.password;
    return data;
  }
}

export interface IUpdateProfileInputDto {
  firstName: string | undefined;
  middleName: string | undefined;
  lastName: string | undefined;
  password: string | undefined;
}

export class FindAllRolesDetailDto implements IFindAllRolesDetailDto {
  /** role id */
  _id!: string;
  /** role name */
  name!: string;
  /** is default */
  isDefault!: boolean;
  /** permissions */
  permissions!: string[];
  /** created by */
  createdBy!: string;
  /** created at */
  createdAt!: moment.Moment;
  /** last modified by */
  lastModifiedBy!: string | undefined;
  /** last modified at */
  lastModifiedAt!: moment.Moment | undefined;

  constructor(data?: IFindAllRolesDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.permissions = [];
    }
  }

  init(data?: any) {
    if (data) {
      this._id = data['_id'];
      this.name = data['name'];
      this.isDefault = data['isDefault'];
      if (data['permissions'] && data['permissions'].constructor === Array) {
        this.permissions = [];
        for (let item of data['permissions']) this.permissions.push(item);
      }
      this.createdBy = data['createdBy'];
      this.createdAt = data['createdAt']
        ? moment(data['createdAt'].toString())
        : <any>undefined;
      this.lastModifiedBy = data['lastModifiedBy'];
      this.lastModifiedAt = data['lastModifiedAt']
        ? moment(data['lastModifiedAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): FindAllRolesDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new FindAllRolesDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['_id'] = this._id;
    data['name'] = this.name;
    data['isDefault'] = this.isDefault;
    if (this.permissions && this.permissions.constructor === Array) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item);
    }
    data['createdBy'] = this.createdBy;
    data['createdAt'] = this.createdAt
      ? this.createdAt.toISOString()
      : <any>undefined;
    data['lastModifiedBy'] = this.lastModifiedBy;
    data['lastModifiedAt'] = this.lastModifiedAt
      ? this.lastModifiedAt.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IFindAllRolesDetailDto {
  /** role id */
  _id: string;
  /** role name */
  name: string;
  /** is default */
  isDefault: boolean;
  /** permissions */
  permissions: string[];
  /** created by */
  createdBy: string;
  /** created at */
  createdAt: moment.Moment;
  /** last modified by */
  lastModifiedBy: string | undefined;
  /** last modified at */
  lastModifiedAt: moment.Moment | undefined;
}

export class FindAllRolesResultDto implements IFindAllRolesResultDto {
  /** data of roles */
  data!: FindAllRolesDetailDto[];
  /** total number of roles */
  total!: number;

  constructor(data?: IFindAllRolesResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.data = [];
    }
  }

  init(data?: any) {
    if (data) {
      if (data['data'] && data['data'].constructor === Array) {
        this.data = [];
        for (let item of data['data'])
          this.data.push(FindAllRolesDetailDto.fromJS(item));
      }
      this.total = data['total'];
    }
  }

  static fromJS(data: any): FindAllRolesResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new FindAllRolesResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.data && this.data.constructor === Array) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['total'] = this.total;
    return data;
  }
}

export interface IFindAllRolesResultDto {
  /** data of roles */
  data: FindAllRolesDetailDto[];
  /** total number of roles */
  total: number;
}

export class CreateRoleInputDto implements ICreateRoleInputDto {
  /** role name */
  name!: string;
  /** is default */
  isDefault!: boolean;
  /** permissions */
  permissions!: any[];

  constructor(data?: ICreateRoleInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.permissions = [];
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data['name'];
      this.isDefault = data['isDefault'];
      if (data['permissions'] && data['permissions'].constructor === Array) {
        this.permissions = [];
        for (let item of data['permissions']) this.permissions.push(item);
      }
    }
  }

  static fromJS(data: any): CreateRoleInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateRoleInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['isDefault'] = this.isDefault;
    if (this.permissions && this.permissions.constructor === Array) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item);
    }
    return data;
  }
}

export interface ICreateRoleInputDto {
  /** role name */
  name: string;
  /** is default */
  isDefault: boolean;
  /** permissions */
  permissions: any[];
}

export class UpdateRoleInputDto implements IUpdateRoleInputDto {
  /** role id */
  _id!: string;
  /** role name */
  name!: string;
  /** permissions */
  permissions!: any[];
  /** is default */
  isDefault!: boolean;

  constructor(data?: IUpdateRoleInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.permissions = [];
    }
  }

  init(data?: any) {
    if (data) {
      this._id = data['_id'];
      this.name = data['name'];
      if (data['permissions'] && data['permissions'].constructor === Array) {
        this.permissions = [];
        for (let item of data['permissions']) this.permissions.push(item);
      }
      this.isDefault = data['isDefault'];
    }
  }

  static fromJS(data: any): UpdateRoleInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateRoleInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['_id'] = this._id;
    data['name'] = this.name;
    if (this.permissions && this.permissions.constructor === Array) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item);
    }
    data['isDefault'] = this.isDefault;
    return data;
  }
}

export interface IUpdateRoleInputDto {
  /** role id */
  _id: string;
  /** role name */
  name: string;
  /** permissions */
  permissions: any[];
  /** is default */
  isDefault: boolean;
}

export class DeleteRoleDto implements IDeleteRoleDto {
  /** role id */
  id!: string;

  constructor(data?: IDeleteRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data['id'];
    }
  }

  static fromJS(data: any): DeleteRoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeleteRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    return data;
  }
}

export interface IDeleteRoleDto {
  /** role id */
  id: string;
}

export class CreateCompanyInputDto implements ICreateCompanyInputDto {
  /** companyname */
  companyname!: string;
  /** telephone */
  telephone!: string;
  /** streetline1 */
  streetline1!: string;
  /** streetline2 */
  streetline2!: string;
  /** city */
  city!: string;
  /** state */
  state!: string;
  /** zipcode */
  zipcode!: string;
  /** country */
  country!: string;
  /** logo */
  logo!: string;
  /** facebookurl */
  facebookurl!: string;
  /** twitterurl */
  twitterurl!: string;
  /** googleplusurl */
  googleplusurl!: string;
  /** linkedidurl */
  linkedidurl!: string;

  constructor(data?: ICreateCompanyInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.companyname = data['companyname'];
      this.telephone = data['telephone'];
      this.streetline1 = data['streetline1'];
      this.streetline2 = data['streetline2'];
      this.city = data['city'];
      this.state = data['state'];
      this.zipcode = data['zipcode'];
      this.country = data['country'];
      this.logo = data['logo'];
      this.facebookurl = data['facebookurl'];
      this.twitterurl = data['twitterurl'];
      this.googleplusurl = data['googleplusurl'];
      this.linkedidurl = data['linkedidurl'];
    }
  }

  static fromJS(data: any): CreateCompanyInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCompanyInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['companyname'] = this.companyname;
    data['telephone'] = this.telephone;
    data['streetline1'] = this.streetline1;
    data['streetline2'] = this.streetline2;
    data['city'] = this.city;
    data['state'] = this.state;
    data['zipcode'] = this.zipcode;
    data['country'] = this.country;
    data['logo'] = this.logo;
    data['facebookurl'] = this.facebookurl;
    data['twitterurl'] = this.twitterurl;
    data['googleplusurl'] = this.googleplusurl;
    data['linkedidurl'] = this.linkedidurl;
    return data;
  }
}

export interface ICreateCompanyInputDto {
  /** companyname */
  companyname: string;
  /** telephone */
  telephone: string;
  /** streetline1 */
  streetline1: string;
  /** streetline2 */
  streetline2: string;
  /** city */
  city: string;
  /** state */
  state: string;
  /** zipcode */
  zipcode: string;
  /** country */
  country: string;
  /** logo */
  logo: string;
  /** facebookurl */
  facebookurl: string;
  /** twitterurl */
  twitterurl: string;
  /** googleplusurl */
  googleplusurl: string;
  /** linkedidurl */
  linkedidurl: string;
}

export class UpdateCompanyInputDto implements IUpdateCompanyInputDto {
  /** companyname */
  companyname!: string;
  /** telephone */
  telephone!: string;
  /** streetline1 */
  streetline1!: string;
  /** streetline2 */
  streetline2!: string;
  /** city */
  city!: string;
  /** state */
  state!: string;
  /** zipcode */
  zipcode!: string;
  /** country */
  country!: string;
  /** logo */
  logo!: string;
  /** facebookurl */
  facebookurl!: string;
  /** twitterurl */
  twitterurl!: string;
  /** googleplusurl */
  googleplusurl!: string;
  /** linkedidurl */
  linkedidurl!: string;

  constructor(data?: IUpdateCompanyInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.companyname = data['companyname'];
      this.telephone = data['telephone'];
      this.streetline1 = data['streetline1'];
      this.streetline2 = data['streetline2'];
      this.city = data['city'];
      this.state = data['state'];
      this.zipcode = data['zipcode'];
      this.country = data['country'];
      this.logo = data['logo'];
      this.facebookurl = data['facebookurl'];
      this.twitterurl = data['twitterurl'];
      this.googleplusurl = data['googleplusurl'];
      this.linkedidurl = data['linkedidurl'];
    }
  }

  static fromJS(data: any): UpdateCompanyInputDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCompanyInputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['companyname'] = this.companyname;
    data['telephone'] = this.telephone;
    data['streetline1'] = this.streetline1;
    data['streetline2'] = this.streetline2;
    data['city'] = this.city;
    data['state'] = this.state;
    data['zipcode'] = this.zipcode;
    data['country'] = this.country;
    data['logo'] = this.logo;
    data['facebookurl'] = this.facebookurl;
    data['twitterurl'] = this.twitterurl;
    data['googleplusurl'] = this.googleplusurl;
    data['linkedidurl'] = this.linkedidurl;
    return data;
  }
}

export interface IUpdateCompanyInputDto {
  /** companyname */
  companyname: string;
  /** telephone */
  telephone: string;
  /** streetline1 */
  streetline1: string;
  /** streetline2 */
  streetline2: string;
  /** city */
  city: string;
  /** state */
  state: string;
  /** zipcode */
  zipcode: string;
  /** country */
  country: string;
  /** logo */
  logo: string;
  /** facebookurl */
  facebookurl: string;
  /** twitterurl */
  twitterurl: string;
  /** googleplusurl */
  googleplusurl: string;
  /** linkedidurl */
  linkedidurl: string;
}

export class GetUploadedImagesDetailDto implements IGetUploadedImagesDetailDto {
  /** image id */
  _id!: string;
  /** hyperlink */
  hyperlink!: string;
  /** file name */
  filename!: string;

  constructor(data?: IGetUploadedImagesDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this._id = data['_id'];
      this.hyperlink = data['hyperlink'];
      this.filename = data['filename'];
    }
  }

  static fromJS(data: any): GetUploadedImagesDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetUploadedImagesDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['_id'] = this._id;
    data['hyperlink'] = this.hyperlink;
    data['filename'] = this.filename;
    return data;
  }
}

export interface IGetUploadedImagesDetailDto {
  /** image id */
  _id: string;
  /** hyperlink */
  hyperlink: string;
  /** file name */
  filename: string;
}

export class GetUploadedImagesResultDto implements IGetUploadedImagesResultDto {
  /** get all uploaded images info */
  result!: GetUploadedImagesDetailDto[];
  /** all albums */
  albums!: string[];

  constructor(data?: IGetUploadedImagesResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.result = [];
      this.albums = [];
    }
  }

  init(data?: any) {
    if (data) {
      if (data['result'] && data['result'].constructor === Array) {
        this.result = [];
        for (let item of data['result'])
          this.result.push(GetUploadedImagesDetailDto.fromJS(item));
      }
      if (data['albums'] && data['albums'].constructor === Array) {
        this.albums = [];
        for (let item of data['albums']) this.albums.push(item);
      }
    }
  }

  static fromJS(data: any): GetUploadedImagesResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetUploadedImagesResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.result && this.result.constructor === Array) {
      data['result'] = [];
      for (let item of this.result) data['result'].push(item.toJSON());
    }
    if (this.albums && this.albums.constructor === Array) {
      data['albums'] = [];
      for (let item of this.albums) data['albums'].push(item);
    }
    return data;
  }
}

export interface IGetUploadedImagesResultDto {
  /** get all uploaded images info */
  result: GetUploadedImagesDetailDto[];
  /** all albums */
  albums: string[];
}

export class UpdateFilenameDto implements IUpdateFilenameDto {
  /** image id */
  imageId!: string;
  /** new filename */
  newName!: string;

  constructor(data?: IUpdateFilenameDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.imageId = data['imageId'];
      this.newName = data['newName'];
    }
  }

  static fromJS(data: any): UpdateFilenameDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateFilenameDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['imageId'] = this.imageId;
    data['newName'] = this.newName;
    return data;
  }
}

export interface IUpdateFilenameDto {
  /** image id */
  imageId: string;
  /** new filename */
  newName: string;
}

export class CreateAlbumDto implements ICreateAlbumDto {
  /** album name */
  albumName!: string;

  constructor(data?: ICreateAlbumDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.albumName = data['albumName'];
    }
  }

  static fromJS(data: any): CreateAlbumDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateAlbumDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['albumName'] = this.albumName;
    return data;
  }
}

export interface ICreateAlbumDto {
  /** album name */
  albumName: string;
}

export class CreateBlogInputDto implements ICreateBlogInputDto {
  /** title */
  title!: string;
  /** subtitle */
  subtitle!: string;
  /** author */
  author!: string;
  /** tags */
  tags!: any;
  /** content */
  content!: string;
  /** imageSrc */
  imageSrc!: string;
  /** viewCount */
  viewCount!: number;
  /** postRating */
  postRating!: number;
  /** postRating */
  previewContent!: string;

  constructor(data?: ICreateBlogInputDto) {
      if (data) {
          for (var property in data) {
              if (data.hasOwnProperty(property))
                  (<any>this)[property] = (<any>data)[property];
          }
      }
      if (!data) {
          this.tags = {};
      }
  }

  init(data?: any) {
      if (data) {
          this.title = data["title"];
          this.subtitle = data["subtitle"];
          this.author = data["author"];
          if (data["tags"]) {
              this.tags = {};
              for (let key in data["tags"]) {
                  if (data["tags"].hasOwnProperty(key))
                      this.tags[key] = data["tags"][key];
              }
          }
          this.content = data["content"];
          this.imageSrc = data["imageSrc"];
          this.viewCount = data["viewCount"];
          this.postRating = data["postRating"];
          this.previewContent = data["previewContent"];
      }
  }

  static fromJS(data: any): CreateBlogInputDto {
      data = typeof data === 'object' ? data : {};
      let result = new CreateBlogInputDto();
      result.init(data);
      return result;
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["title"] = this.title;
      data["subtitle"] = this.subtitle;
      data["author"] = this.author;
      if (this.tags) {
          data["tags"] = {};
          for (let key in this.tags) {
              if (this.tags.hasOwnProperty(key))
                  data["tags"][key] = this.tags[key];
          }
      }
      data["content"] = this.content;
      data["imageSrc"] = this.imageSrc;
      data["viewCount"] = this.viewCount;
      data["postRating"] = this.postRating;
      data["previewContent"] = this.previewContent;
      return data; 
  }
}

export interface ICreateBlogInputDto {
  /** title */
  title: string;
  /** subtitle */
  subtitle: string;
  /** author */
  author: string;
  /** tags */
  tags: any;
  /** content */
  content: string;
  /** imageSrc */
  imageSrc: string;
  /** viewCount */
  viewCount: number;
  /** postRating */
  postRating: number;
  /** postRating */
  previewContent: string;
}

export class UpdateBlogDetailDto implements IUpdateBlogDetailDto {
  /** title */
  title!: string;
  /** subtitle */
  subtitle!: string;
  /** author */
  author!: string;
  /** tags */
  tags!: any;
  /** content */
  content!: string;
  /** imageSrc */
  imageSrc!: string;
  /** viewCount */
  viewCount!: number;
  /** postRating */
  postRating!: number;
  /** postRating */
  previewContent!: string;

  constructor(data?: IUpdateBlogDetailDto) {
      if (data) {
          for (var property in data) {
              if (data.hasOwnProperty(property))
                  (<any>this)[property] = (<any>data)[property];
          }
      }
      if (!data) {
          this.tags = {};
      }
  }

  init(data?: any) {
      if (data) {
          this.title = data["title"];
          this.subtitle = data["subtitle"];
          this.author = data["author"];
          if (data["tags"]) {
              this.tags = {};
              for (let key in data["tags"]) {
                  if (data["tags"].hasOwnProperty(key))
                      this.tags[key] = data["tags"][key];
              }
          }
          this.content = data["content"];
          this.imageSrc = data["imageSrc"];
          this.viewCount = data["viewCount"];
          this.postRating = data["postRating"];
          this.previewContent = data["previewContent"];
      }
  }

  static fromJS(data: any): UpdateBlogDetailDto {
      data = typeof data === 'object' ? data : {};
      let result = new UpdateBlogDetailDto();
      result.init(data);
      return result;
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["title"] = this.title;
      data["subtitle"] = this.subtitle;
      data["author"] = this.author;
      if (this.tags) {
          data["tags"] = {};
          for (let key in this.tags) {
              if (this.tags.hasOwnProperty(key))
                  data["tags"][key] = this.tags[key];
          }
      }
      data["content"] = this.content;
      data["imageSrc"] = this.imageSrc;
      data["viewCount"] = this.viewCount;
      data["postRating"] = this.postRating;
      data["previewContent"] = this.previewContent;
      return data; 
  }
}

export interface IUpdateBlogDetailDto {
  /** title */
  title: string;
  /** subtitle */
  subtitle: string;
  /** author */
  author: string;
  /** tags */
  tags: any;
  /** content */
  content: string;
  /** imageSrc */
  imageSrc: string;
  /** viewCount */
  viewCount: number;
  /** postRating */
  postRating: number;
  /** postRating */
  previewContent: string;
}

export class FindBlogDetailDto implements IFindBlogDetailDto {
  /** title */
  title!: string;
  /** subtitle */
  subtitle!: string;
  /** author */
  author!: string;
  /** tags */
  tags!: any;
  /** content */
  content!: string;
  /** imageSrc */
  imageSrc!: string;
  /** viewCount */
  viewCount!: number;
  /** postRating */
  postRating!: number;
  /** postId */
  _id!: string;
  /** deactivation status */
  deactivate!: boolean;

  constructor(data?: IFindBlogDetailDto) {
      if (data) {
          for (var property in data) {
              if (data.hasOwnProperty(property))
                  (<any>this)[property] = (<any>data)[property];
          }
      }
      if (!data) {
          this.tags = {};
      }
  }

  init(data?: any) {
      if (data) {
          this.title = data["title"];
          this.subtitle = data["subtitle"];
          this.author = data["author"];
          if (data["tags"]) {
              this.tags = {};
              for (let key in data["tags"]) {
                  if (data["tags"].hasOwnProperty(key))
                      this.tags[key] = data["tags"][key];
              }
          }
          this.content = data["content"];
          this.imageSrc = data["imageSrc"];
          this.viewCount = data["viewCount"];
          this.postRating = data["postRating"];
          this._id = data["_id"];
          this.deactivate = data["deactivate"];
      }
  }

  static fromJS(data: any): FindBlogDetailDto {
      data = typeof data === 'object' ? data : {};
      let result = new FindBlogDetailDto();
      result.init(data);
      return result;
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["title"] = this.title;
      data["subtitle"] = this.subtitle;
      data["author"] = this.author;
      if (this.tags) {
          data["tags"] = {};
          for (let key in this.tags) {
              if (this.tags.hasOwnProperty(key))
                  data["tags"][key] = this.tags[key];
          }
      }
      data["content"] = this.content;
      data["imageSrc"] = this.imageSrc;
      data["viewCount"] = this.viewCount;
      data["postRating"] = this.postRating;
      data["_id"] = this._id;
      data["deactivate"] = this.deactivate;
      return data; 
  }
}

export interface IFindBlogDetailDto {
  /** title */
  title: string;
  /** subtitle */
  subtitle: string;
  /** author */
  author: string;
  /** tags */
  tags: any;
  /** content */
  content: string;
  /** imageSrc */
  imageSrc: string;
  /** viewCount */
  viewCount: number;
  /** postRating */
  postRating: number;
  /** postId */
  _id: string;
  /** deactivation status */
  deactivate: boolean;
}

export class FindAllBlogPostsDto implements IFindAllBlogPostsDto {
  /** Arrays of FindBlogDetailDto */
  data!: FindBlogDetailDto[];

  constructor(data?: IFindAllBlogPostsDto) {
      if (data) {
          for (var property in data) {
              if (data.hasOwnProperty(property))
                  (<any>this)[property] = (<any>data)[property];
          }
      }
      if (!data) {
          this.data = [];
      }
  }

  init(data?: any) {
      if (data) {
          if (data["data"] && data["data"].constructor === Array) {
              this.data = [];
              for (let item of data["data"])
                  this.data.push(FindBlogDetailDto.fromJS(item));
          }
      }
  }

  static fromJS(data: any): FindAllBlogPostsDto {
      data = typeof data === 'object' ? data : {};
      let result = new FindAllBlogPostsDto();
      result.init(data);
      return result;
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (this.data && this.data.constructor === Array) {
          data["data"] = [];
          for (let item of this.data)
              data["data"].push(item.toJSON());
      }
      return data; 
  }
}

export interface IFindAllBlogPostsDto {
  /** Arrays of FindBlogDetailDto */
  data: FindBlogDetailDto[];
}

export class SearchInputDto implements ISearchInputDto {
  /** searchInput */
  searchInput!: string;

  constructor(data?: ISearchInputDto) {
      if (data) {
          for (var property in data) {
              if (data.hasOwnProperty(property))
                  (<any>this)[property] = (<any>data)[property];
          }
      }
  }

  init(data?: any) {
      if (data) {
          this.searchInput = data["searchInput"];
      }
  }

  static fromJS(data: any): SearchInputDto {
      data = typeof data === 'object' ? data : {};
      let result = new SearchInputDto();
      result.init(data);
      return result;
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["searchInput"] = this.searchInput;
      return data; 
  }
}

export interface ISearchInputDto {
  /** searchInput */
  searchInput: string;
}

export class DateRangeInputDto implements IDateRangeInputDto {
  /** DateRangeInputDto */
  dateRangeInput!: any[];

  constructor(data?: IDateRangeInputDto) {
      if (data) {
          for (var property in data) {
              if (data.hasOwnProperty(property))
                  (<any>this)[property] = (<any>data)[property];
          }
      }
      if (!data) {
          this.dateRangeInput = [];
      }
  }

  init(data?: any) {
      if (data) {
          if (data["dateRangeInput"] && data["dateRangeInput"].constructor === Array) {
              this.dateRangeInput = [];
              for (let item of data["dateRangeInput"])
                  this.dateRangeInput.push(item);
          }
      }
  }

  static fromJS(data: any): DateRangeInputDto {
      data = typeof data === 'object' ? data : {};
      let result = new DateRangeInputDto();
      result.init(data);
      return result;
  }

  toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (this.dateRangeInput && this.dateRangeInput.constructor === Array) {
          data["dateRangeInput"] = [];
          for (let item of this.dateRangeInput)
              data["dateRangeInput"].push(item);
      }
      return data; 
  }
}

export interface IDateRangeInputDto {
  /** DateRangeInputDto */
  dateRangeInput: any[];
}

export class GetLanguageResultDto implements IGetLanguageResultDto {
  /** get language result */
  result!: any;

  constructor(data?: IGetLanguageResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.result = {};
    }
  }

  init(data?: any) {
    if (data) {
      if (data['result']) {
        this.result = {};
        for (let key in data['result']) {
          if (data['result'].hasOwnProperty(key))
            this.result[key] = data['result'][key];
        }
      }
    }
  }

  static fromJS(data: any): GetLanguageResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetLanguageResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.result) {
      data['result'] = {};
      for (let key in this.result) {
        if (this.result.hasOwnProperty(key))
          data['result'][key] = this.result[key];
      }
    }
    return data;
  }
}

export interface IGetLanguageResultDto {
  /** get language result */
  result: any;
}

export class SwaggerException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new SwaggerException(message, status, response, headers, null);
}
