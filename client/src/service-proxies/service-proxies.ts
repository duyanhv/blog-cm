/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.13.0 (NJsonSchema v9.10.50.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import * as moment from 'moment';

export class UsersServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Find users
     * @name (optional) username or fullname
     * @role (optional) role
     * @pageIndex (optional) page index, default value is 0
     * @itemPerPageCount (optional) request item, default value is 10
     * @sortBy sort field
     * @asc sort order
     * @return Return information of selected users
     */
    find(name: string | null | undefined, role: string | null | undefined, pageIndex: number | null | undefined, itemPerPageCount: number | null | undefined, sortBy: string, asc: boolean): Promise<FindAllUsersResultDto> {
        let url_ = this.baseUrl + "/users/find?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (role !== undefined)
            url_ += "role=" + encodeURIComponent("" + role) + "&"; 
        if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (itemPerPageCount !== undefined)
            url_ += "itemPerPageCount=" + encodeURIComponent("" + itemPerPageCount) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (asc === undefined || asc === null)
            throw new Error("The parameter 'asc' must be defined and cannot be null.");
        else
            url_ += "asc=" + encodeURIComponent("" + asc) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<FindAllUsersResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindAllUsersResultDto.fromJS(resultData200) : new FindAllUsersResultDto();
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllUsersResultDto>(<any>null);
    }

    /**
     * Find an user by username
     * @return Return information of selected users
     */
    findByUsername(username: string): Promise<FindUserResultDto> {
        let url_ = this.baseUrl + "/users/findByUsername/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindByUsername(_response);
        });
    }

    protected processFindByUsername(response: Response): Promise<FindUserResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindUserResultDto.fromJS(resultData200) : new FindUserResultDto();
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindUserResultDto>(<any>null);
    }

    /**
     * Find an user by email
     * @return Return information of selected users
     */
    findByEmail(email: string): Promise<FindUserResultDto> {
        let url_ = this.baseUrl + "/users/findByEmail/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindByEmail(_response);
        });
    }

    protected processFindByEmail(response: Response): Promise<FindUserResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindUserResultDto.fromJS(resultData200) : new FindUserResultDto();
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindUserResultDto>(<any>null);
    }

    /**
     * Create user
     * @return The user has been successfully created.
     */
    create(createUserInputDto: CreateUserInputDto): Promise<FindAllUsersDetailDto> {
        let url_ = this.baseUrl + "/users/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createUserInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FindAllUsersDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? FindAllUsersDetailDto.fromJS(resultData201) : new FindAllUsersDetailDto();
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllUsersDetailDto>(<any>null);
    }

    /**
     * Update user
     * @return The user has been successfully updated.
     */
    update(updateUserInputDto: UpdateUserInputDto): Promise<void> {
        let url_ = this.baseUrl + "/users/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateUserInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Deactivate user
     * @return The user has been successfully deactivated.
     */
    deactivate(username: string): Promise<void> {
        let url_ = this.baseUrl + "/users/{username}/deactivate";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Unlock user
     * @return The profile has been successfully unlocked.
     */
    unlock(username: string): Promise<void> {
        let url_ = this.baseUrl + "/users/{username}/unlock";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnlock(_response);
        });
    }

    protected processUnlock(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AuthServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Login with username & password
     * @return Login successfully
     */
    login(loginUserInputDto: LoginUserInputDto): Promise<TokenInfoDto> {
        let url_ = this.baseUrl + "/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginUserInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<TokenInfoDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? TokenInfoDto.fromJS(resultData201) : new TokenInfoDto();
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenInfoDto>(<any>null);
    }

    /**
     * Get new token
     * @return Refresh successfully
     */
    refreshToken(refreshTokenDto: RefreshTokenDto): Promise<TokenInfoDto> {
        let url_ = this.baseUrl + "/auth/refreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshTokenDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: Response): Promise<TokenInfoDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? TokenInfoDto.fromJS(resultData201) : new TokenInfoDto();
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenInfoDto>(<any>null);
    }

    /**
     * Google Authentication
     */
    loginWithGoogle(): Promise<void> {
        let url_ = this.baseUrl + "/auth/loginWithGoogle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoginWithGoogle(_response);
        });
    }

    protected processLoginWithGoogle(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    loginWithGoogleCallback(): Promise<void> {
        let url_ = this.baseUrl + "/auth/loginWithGoogleCallback";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoginWithGoogleCallback(_response);
        });
    }

    protected processLoginWithGoogleCallback(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Facebook Authentication
     */
    loginWithFacebook(): Promise<void> {
        let url_ = this.baseUrl + "/auth/loginWithFacebook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoginWithFacebook(_response);
        });
    }

    protected processLoginWithFacebook(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    loginWithFacebookCallback(): Promise<void> {
        let url_ = this.baseUrl + "/auth/loginWithFacebookCallback";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoginWithFacebookCallback(_response);
        });
    }

    protected processLoginWithFacebookCallback(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Register user
     * @return The user has been successfully created.
     */
    register(registerUserInputDto: RegisterUserInputDto): Promise<void> {
        let url_ = this.baseUrl + "/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerUserInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ProfilesServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Get user profile
     * @return Return user profile
     */
    get(id: string): Promise<GetProfileResultDto> {
        let url_ = this.baseUrl + "/profiles/get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<GetProfileResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfileResultDto.fromJS(resultData200) : new GetProfileResultDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetProfileResultDto>(<any>null);
    }

    /**
     * Update user profile
     * @return Profile has been successfully updated
     */
    update(updateProfileInputDto: UpdateProfileInputDto): Promise<void> {
        let url_ = this.baseUrl + "/profiles/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateProfileInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Upload profile picture
     * @return Upload profile picture success
     */
    uploadProfilePicture(): Promise<string> {
        let url_ = this.baseUrl + "/profiles/uploadProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadProfilePicture(_response);
        });
    }

    protected processUploadProfilePicture(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class RolesServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Find roles
     * @name (optional) role name
     * @permissions (optional) role permissions
     * @pageIndex page index
     * @itemPerPageCount page size
     * @sortBy sort field
     * @asc sort order
     * @return Return information of selected roles
     */
    find(name: string | null | undefined, permissions: any[] | null | undefined, pageIndex: number, itemPerPageCount: number, sortBy: string, asc: boolean): Promise<FindAllRolesResultDto> {
        let url_ = this.baseUrl + "/roles/find?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "permissions=" + encodeURIComponent("" + item) + "&"; });
        if (pageIndex === undefined || pageIndex === null)
            throw new Error("The parameter 'pageIndex' must be defined and cannot be null.");
        else
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (itemPerPageCount === undefined || itemPerPageCount === null)
            throw new Error("The parameter 'itemPerPageCount' must be defined and cannot be null.");
        else
            url_ += "itemPerPageCount=" + encodeURIComponent("" + itemPerPageCount) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (asc === undefined || asc === null)
            throw new Error("The parameter 'asc' must be defined and cannot be null.");
        else
            url_ += "asc=" + encodeURIComponent("" + asc) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<FindAllRolesResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindAllRolesResultDto.fromJS(resultData200) : new FindAllRolesResultDto();
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllRolesResultDto>(<any>null);
    }

    /**
     * Create role
     * @return Return information of new created role
     */
    create(createRoleInputDto: CreateRoleInputDto): Promise<FindAllRolesDetailDto> {
        let url_ = this.baseUrl + "/roles/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRoleInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FindAllRolesDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? FindAllRolesDetailDto.fromJS(resultData201) : new FindAllRolesDetailDto();
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllRolesDetailDto>(<any>null);
    }

    /**
     * Update role
     * @return Update Role Success
     */
    update(updateRoleInputDto: UpdateRoleInputDto): Promise<FindAllRolesDetailDto> {
        let url_ = this.baseUrl + "/roles/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRoleInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FindAllRolesDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindAllRolesDetailDto.fromJS(resultData200) : new FindAllRolesDetailDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllRolesDetailDto>(<any>null);
    }

    /**
     * Delete role
     * @return Delete Success
     */
    delete(deleteRoleDto: DeleteRoleDto): Promise<FindAllRolesDetailDto> {
        let url_ = this.baseUrl + "/roles/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteRoleDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FindAllRolesDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindAllRolesDetailDto.fromJS(resultData200) : new FindAllRolesDetailDto();
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllRolesDetailDto>(<any>null);
    }
}

export class AppSettingsServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Get App Settings
     * @return Return app settings
     */
    get(): Promise<any> {
        let url_ = this.baseUrl + "/appSettings/get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export class I18nServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Get Language Translatation
     * @lng language
     * @return Get Language Translatation
     */
    getLanguage(lng: string): Promise<GetLanguageResultDto> {
        let url_ = this.baseUrl + "/i18n/getLanguage?";
        if (lng === undefined || lng === null)
            throw new Error("The parameter 'lng' must be defined and cannot be null.");
        else
            url_ += "lng=" + encodeURIComponent("" + lng) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLanguage(_response);
        });
    }

    protected processGetLanguage(response: Response): Promise<GetLanguageResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageResultDto.fromJS(resultData200) : new GetLanguageResultDto();
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetLanguageResultDto>(<any>null);
    }
}

export class CompanyServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Create company
     * @return The company has been successfully created.
     */
    create(createCompanyInputDto: CreateCompanyInputDto): Promise<void> {
        let url_ = this.baseUrl + "/company/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createCompanyInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update company infomation
     * @return Update company infomation Success
     */
    update(updateCompanyInputDto: UpdateCompanyInputDto): Promise<void> {
        let url_ = this.baseUrl + "/company/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateCompanyInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find company
     * @return Return information of company
     */
    find(): Promise<any> {
        let url_ = this.baseUrl + "/company/find";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Upload Image
     * @return Upload Successful
     */
    upload(): Promise<string> {
        let url_ = this.baseUrl + "/company/upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * Upload Image
     * @return Upload Successful
     */
    getCompanyLogo(): Promise<string> {
        let url_ = this.baseUrl + "/company/getCompanyLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompanyLogo(_response);
        });
    }

    protected processGetCompanyLogo(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class UploadImagesServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Upload images
     * @return Upload images success
     */
    upload(): Promise<GetUploadedImagesDetailDto> {
        let url_ = this.baseUrl + "/uploadImages/upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<GetUploadedImagesDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUploadedImagesDetailDto.fromJS(resultData200) : new GetUploadedImagesDetailDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetUploadedImagesDetailDto>(<any>null);
    }

    /**
     * Get user uploaded images
     * @return Return user uploaded images
     */
    get(search: string, id: string): Promise<GetUploadedImagesResultDto> {
        let url_ = this.baseUrl + "/uploadImages/get/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (search === undefined || search === null)
            throw new Error("The parameter 'search' must be defined and cannot be null.");
        else
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<GetUploadedImagesResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUploadedImagesResultDto.fromJS(resultData200) : new GetUploadedImagesResultDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetUploadedImagesResultDto>(<any>null);
    }

    /**
     * Get all albums
     * @return Return albums info
     */
    albums(): Promise<GetUploadedImagesResultDto> {
        let url_ = this.baseUrl + "/uploadImages/albums";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAlbums(_response);
        });
    }

    protected processAlbums(response: Response): Promise<GetUploadedImagesResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUploadedImagesResultDto.fromJS(resultData200) : new GetUploadedImagesResultDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetUploadedImagesResultDto>(<any>null);
    }

    /**
     * Get all images of an album
     * @return Return all images of an album
     */
    getImages(albumName: string): Promise<GetAlbumImagesResultDto> {
        let url_ = this.baseUrl + "/uploadImages/getImages/{albumName}";
        if (albumName === undefined || albumName === null)
            throw new Error("The parameter 'albumName' must be defined.");
        url_ = url_.replace("{albumName}", encodeURIComponent("" + albumName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetImages(_response);
        });
    }

    protected processGetImages(response: Response): Promise<GetAlbumImagesResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetAlbumImagesResultDto.fromJS(resultData200) : new GetAlbumImagesResultDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAlbumImagesResultDto>(<any>null);
    }

    /**
     * Upload image filename
     * @return Upload image filename
     */
    updateFilename(updateFilenameDto: UpdateFilenameDto): Promise<void> {
        let url_ = this.baseUrl + "/uploadImages/updateFilename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateFilenameDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFilename(_response);
        });
    }

    protected processUpdateFilename(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete image
     * @return Delete image success
     */
    deleteImage(imageId: string): Promise<void> {
        let url_ = this.baseUrl + "/uploadImages/deleteImage/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteImage(_response);
        });
    }

    protected processDeleteImage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create a new album
     * @return Create album success
     */
    createAlbum(createAlbumDto: CreateAlbumDto): Promise<void> {
        let url_ = this.baseUrl + "/uploadImages/createAlbum";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createAlbumDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAlbum(_response);
        });
    }

    protected processCreateAlbum(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class BlogServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Add new post
     * @return A new post has been successfully created.
     */
    newpost(createBlogInputDto: CreateBlogInputDto): Promise<void> {
        let url_ = this.baseUrl + "/blog/newpost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createBlogInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNewpost(_response);
        });
    }

    protected processNewpost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Edit Post
     * @return Post has been successfully edited.
     */
    edit(id: string, updateBlogDetailDto: UpdateBlogDetailDto): Promise<UpdateBlogDetailDto> {
        let url_ = this.baseUrl + "/blog/edit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateBlogDetailDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEdit(_response);
        });
    }

    protected processEdit(response: Response): Promise<UpdateBlogDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? UpdateBlogDetailDto.fromJS(resultData201) : new UpdateBlogDetailDto();
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UpdateBlogDetailDto>(<any>null);
    }

    /**
     * Delete Post
     * @return Post has been successfully deleted.
     */
    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/blog/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Deactivate Post
     * @return Post has been successfully Deactivated.
     */
    deactivatePost(id: string): Promise<void> {
        let url_ = this.baseUrl + "/blog/deactivate-post/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeactivatePost(_response);
        });
    }

    protected processDeactivatePost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Activate Post
     * @return Post has been successfully Activated.
     */
    activatePost(id: string): Promise<void> {
        let url_ = this.baseUrl + "/blog/activate-post/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivatePost(_response);
        });
    }

    protected processActivatePost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get All Post
     * @return Posts has been fetched successfully.
     */
    getpost(): Promise<FindAllBlogPostsDto> {
        let url_ = this.baseUrl + "/blog/getpost";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetpost(_response);
        });
    }

    protected processGetpost(response: Response): Promise<FindAllBlogPostsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindAllBlogPostsDto.fromJS(resultData200) : new FindAllBlogPostsDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllBlogPostsDto>(<any>null);
    }

    /**
     * Get all post title
     */
    getAllPostTitle(): Promise<void> {
        let url_ = this.baseUrl + "/blog/getAllPostTitle";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPostTitle(_response);
        });
    }

    protected processGetAllPostTitle(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * findPostByTitle
     * @return Post title has been successfully fetched.
     */
    findPostByTitle(searchInputDto: SearchInputDto): Promise<FindAllBlogPostsDto> {
        let url_ = this.baseUrl + "/blog/findPostByTitle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindPostByTitle(_response);
        });
    }

    protected processFindPostByTitle(response: Response): Promise<FindAllBlogPostsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? FindAllBlogPostsDto.fromJS(resultData201) : new FindAllBlogPostsDto();
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllBlogPostsDto>(<any>null);
    }

    /**
     * findPostByDate
     * @return Post title has been successfully fetched.
     */
    findPostByDate(dateRangeInputDto: DateRangeInputDto): Promise<FindAllBlogPostsDto> {
        let url_ = this.baseUrl + "/blog/findPostByDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dateRangeInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindPostByDate(_response);
        });
    }

    protected processFindPostByDate(response: Response): Promise<FindAllBlogPostsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? FindAllBlogPostsDto.fromJS(resultData201) : new FindAllBlogPostsDto();
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllBlogPostsDto>(<any>null);
    }

    /**
     * getActivePost
     * @return Posts has been fetched successfully.
     */
    getActivePost(): Promise<FindAllBlogPostsDto> {
        let url_ = this.baseUrl + "/blog/getActivePost";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivePost(_response);
        });
    }

    protected processGetActivePost(response: Response): Promise<FindAllBlogPostsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindAllBlogPostsDto.fromJS(resultData200) : new FindAllBlogPostsDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllBlogPostsDto>(<any>null);
    }

    /**
     * getpostpublic
     * @return Posts has been fetched successfully.
     */
    getpostpublic(): Promise<FindAllBlogPostsDto> {
        let url_ = this.baseUrl + "/blog/getpostpublic";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetpostpublic(_response);
        });
    }

    protected processGetpostpublic(response: Response): Promise<FindAllBlogPostsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindAllBlogPostsDto.fromJS(resultData200) : new FindAllBlogPostsDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllBlogPostsDto>(<any>null);
    }

    /**
     * getpostbyid
     * @return Post has been successfully fetched.
     */
    getpostbyid(id: string): Promise<void> {
        let url_ = this.baseUrl + "/blog/getpostbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetpostbyid(_response);
        });
    }

    protected processGetpostbyid(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * getlastestpost
     * @return Post has been successfully fetched.
     */
    getlastestpost(): Promise<void> {
        let url_ = this.baseUrl + "/blog/getlastestpost";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetlastestpost(_response);
        });
    }

    protected processGetlastestpost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class TeachersServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Find Teachers
     * @name (optional) search by name
     * @subject (optional) filter by subject
     * @pageNumber page number
     * @pageSize page size
     * @sortBy sort by
     * @asc sort order asc
     * @return Return user uploaded images
     */
    find(name: string | null | undefined, subject: string | null | undefined, pageNumber: number, pageSize: number, sortBy: string, asc: boolean): Promise<FindTeachersResultDto> {
        let url_ = this.baseUrl + "/teachers/find?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (subject !== undefined)
            url_ += "subject=" + encodeURIComponent("" + subject) + "&"; 
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (asc === undefined || asc === null)
            throw new Error("The parameter 'asc' must be defined and cannot be null.");
        else
            url_ += "asc=" + encodeURIComponent("" + asc) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFind(_response);
        });
    }

    protected processFind(response: Response): Promise<FindTeachersResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindTeachersResultDto.fromJS(resultData200) : new FindTeachersResultDto();
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindTeachersResultDto>(<any>null);
    }

    /**
     * Get Teacher Info
     * @return Return Teacher Info
     */
    getTeacherDetail(teacherId: string): Promise<FindTeachersDetailDto> {
        let url_ = this.baseUrl + "/teachers/getTeacherDetail/{teacherId}";
        if (teacherId === undefined || teacherId === null)
            throw new Error("The parameter 'teacherId' must be defined.");
        url_ = url_.replace("{teacherId}", encodeURIComponent("" + teacherId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTeacherDetail(_response);
        });
    }

    protected processGetTeacherDetail(response: Response): Promise<FindTeachersDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindTeachersDetailDto.fromJS(resultData200) : new FindTeachersDetailDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindTeachersDetailDto>(<any>null);
    }

    /**
     * Create Teacher
     * @return Create Teacher Success
     */
    create(createTeacherInputDto: CreateTeacherInputDto): Promise<FindTeachersDetailDto> {
        let url_ = this.baseUrl + "/teachers/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createTeacherInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FindTeachersDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? FindTeachersDetailDto.fromJS(resultData201) : new FindTeachersDetailDto();
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindTeachersDetailDto>(<any>null);
    }

    /**
     * Active Teacher
     * @teacherId teacher id
     * @return Active Teacher Success
     */
    activate(teacherId: string): Promise<void> {
        let url_ = this.baseUrl + "/teachers/activate?";
        if (teacherId === undefined || teacherId === null)
            throw new Error("The parameter 'teacherId' must be defined and cannot be null.");
        else
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Deactive Teacher
     * @teacherId teacher id
     * @return Deactive Teacher Success
     */
    deactivate(teacherId: string): Promise<void> {
        let url_ = this.baseUrl + "/teachers/deactivate?";
        if (teacherId === undefined || teacherId === null)
            throw new Error("The parameter 'teacherId' must be defined and cannot be null.");
        else
            url_ += "teacherId=" + encodeURIComponent("" + teacherId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update Teacher Info
     * @return Update Teacher Info Success
     */
    update(updateTeacherInfoDto: UpdateTeacherInfoDto): Promise<void> {
        let url_ = this.baseUrl + "/teachers/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateTeacherInfoDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update Teacher Profile Picture
     * @return Update Teacher Profile Picture Success
     */
    uploadProfilePicture(): Promise<void> {
        let url_ = this.baseUrl + "/teachers/uploadProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadProfilePicture(_response);
        });
    }

    protected processUploadProfilePicture(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class MenuconfigServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * findAllMenuConfig
     * @return Menu Config has successfully been fetched
     */
    findAllMenuConfig(): Promise<FindAllMenuConfigDto> {
        let url_ = this.baseUrl + "/menuconfig/findAllMenuConfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindAllMenuConfig(_response);
        });
    }

    protected processFindAllMenuConfig(response: Response): Promise<FindAllMenuConfigDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindAllMenuConfigDto.fromJS(resultData200) : new FindAllMenuConfigDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllMenuConfigDto>(<any>null);
    }

    /**
     * findMenuConfigById
     * @return Menu Config has successfully been fetched
     */
    findMenuConfigById(id: string): Promise<FindMenuConfigDto> {
        let url_ = this.baseUrl + "/menuconfig/findMenuConfigById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindMenuConfigById(_response);
        });
    }

    protected processFindMenuConfigById(response: Response): Promise<FindMenuConfigDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindMenuConfigDto.fromJS(resultData200) : new FindMenuConfigDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindMenuConfigDto>(<any>null);
    }

    /**
     * findparentidmenuconfig
     * @return Menu Config has successfully been fetched
     */
    findparentidmenuconfig(): Promise<FindAllParentIdMenuConfigDto> {
        let url_ = this.baseUrl + "/menuconfig/findparentidmenuconfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindparentidmenuconfig(_response);
        });
    }

    protected processFindparentidmenuconfig(response: Response): Promise<FindAllParentIdMenuConfigDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FindAllParentIdMenuConfigDto.fromJS(resultData200) : new FindAllParentIdMenuConfigDto();
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindAllParentIdMenuConfigDto>(<any>null);
    }

    /**
     * createMenuConfig
     * @return A new post has been successfully created.
     */
    createMenuConfig(createMenuConfigDto: CreateMenuConfigDto): Promise<void> {
        let url_ = this.baseUrl + "/menuconfig/createMenuConfig";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createMenuConfigDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMenuConfig(_response);
        });
    }

    protected processCreateMenuConfig(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * updatemenuconfig
     * @return Menuconfig has successfully edited
     */
    updateMenuConfig(updateMenuConfigDto: UpdateMenuConfigDto, id: string): Promise<void> {
        let url_ = this.baseUrl + "/menuconfig/updateMenuConfig/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateMenuConfigDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMenuConfig(_response);
        });
    }

    protected processUpdateMenuConfig(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * deactivatemenuconfig
     * @return Menuconfig has successfully deactivated
     */
    deactivateMenuConfig(id: string): Promise<void> {
        let url_ = this.baseUrl + "/menuconfig/deactivateMenuConfig/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeactivateMenuConfig(_response);
        });
    }

    protected processDeactivateMenuConfig(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * activatemenuconfig
     * @return Menuconfig has successfully activated
     */
    activateMenuConfig(id: string): Promise<void> {
        let url_ = this.baseUrl + "/menuconfig/activateMenuConfig/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivateMenuConfig(_response);
        });
    }

    protected processActivateMenuConfig(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class StudyResultServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Get Attendance Record
     * @return Get Attendance Record Success
     */
    attendanceRecord(getAttendanceRecordInputDto: GetAttendanceRecordInputDto): Promise<void> {
        let url_ = this.baseUrl + "/study-result/attendance-record";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(getAttendanceRecordInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAttendanceRecord(_response);
        });
    }

    protected processAttendanceRecord(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    gradeBook(): Promise<void> {
        let url_ = this.baseUrl + "/study-result/grade-book";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGradeBook(_response);
        });
    }

    protected processGradeBook(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class TimeTableServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http:///api";
    }

    /**
     * Register Class
     * @return Register Class Success
     */
    register(registerInputDto: RegisterInputDto): Promise<void> {
        let url_ = this.baseUrl + "/time-table/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerInputDto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class FindAllUsersDetailDto implements IFindAllUsersDetailDto {
    /** user id */
    _id!: string;
    /** username */
    username!: string;
    /** first name */
    firstName!: string;
    /** middle name */
    middleName!: string | undefined;
    /** last name */
    lastName!: string;
    /** full name */
    fullName!: string;
    /** email */
    email!: string;
    /** role */
    roles!: any[];
    /** permissions */
    permissions!: any[];
    /** is active */
    isActive!: boolean;

    constructor(data?: IFindAllUsersDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
            this.permissions = [];
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.username = data["username"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.fullName = data["fullName"];
            this.email = data["email"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(item);
            }
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): FindAllUsersDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindAllUsersDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IFindAllUsersDetailDto {
    /** user id */
    _id: string;
    /** username */
    username: string;
    /** first name */
    firstName: string;
    /** middle name */
    middleName: string | undefined;
    /** last name */
    lastName: string;
    /** full name */
    fullName: string;
    /** email */
    email: string;
    /** role */
    roles: any[];
    /** permissions */
    permissions: any[];
    /** is active */
    isActive: boolean;
}

export class FindAllUsersResultDto implements IFindAllUsersResultDto {
    /** data of users */
    data!: FindAllUsersDetailDto[];
    /** total number of users */
    total!: number;

    constructor(data?: IFindAllUsersResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(FindAllUsersDetailDto.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): FindAllUsersResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindAllUsersResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface IFindAllUsersResultDto {
    /** data of users */
    data: FindAllUsersDetailDto[];
    /** total number of users */
    total: number;
}

export class FindUserResultDto implements IFindUserResultDto {
    username!: string;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    email!: string;

    constructor(data?: IFindUserResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): FindUserResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindUserResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data; 
    }
}

export interface IFindUserResultDto {
    username: string;
    firstName: string;
    middleName: string;
    lastName: string;
    email: string;
}

export class CreateUserInputDto implements ICreateUserInputDto {
    /** username */
    username!: string;
    /** password */
    password!: string;
    /** first name */
    firstName!: string;
    /** middle name */
    middleName!: string | undefined;
    /** last name */
    lastName!: string;
    /** email */
    email!: string;
    /** roles */
    roles!: any[];
    /** permissions */
    permissions!: any[];

    constructor(data?: ICreateUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
            this.permissions = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.password = data["password"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(item);
            }
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }
}

export interface ICreateUserInputDto {
    /** username */
    username: string;
    /** password */
    password: string;
    /** first name */
    firstName: string;
    /** middle name */
    middleName: string | undefined;
    /** last name */
    lastName: string;
    /** email */
    email: string;
    /** roles */
    roles: any[];
    /** permissions */
    permissions: any[];
}

export class UpdateUserInputDto implements IUpdateUserInputDto {
    /** user id */
    _id!: string;
    /** username */
    username!: string;
    /** password */
    password!: string | undefined;
    /** email */
    email!: string;
    /** firstName */
    firstName!: string;
    /** middleName */
    middleName!: string;
    /** lastName */
    lastName!: string;
    /** roles */
    roles!: any[];
    /** permissions */
    permissions!: any[];
    /** is active */
    isActive!: boolean;

    constructor(data?: IUpdateUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
            this.permissions = [];
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.username = data["username"];
            this.password = data["password"];
            this.email = data["email"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(item);
            }
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UpdateUserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["username"] = this.username;
        data["password"] = this.password;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IUpdateUserInputDto {
    /** user id */
    _id: string;
    /** username */
    username: string;
    /** password */
    password: string | undefined;
    /** email */
    email: string;
    /** firstName */
    firstName: string;
    /** middleName */
    middleName: string;
    /** lastName */
    lastName: string;
    /** roles */
    roles: any[];
    /** permissions */
    permissions: any[];
    /** is active */
    isActive: boolean;
}

export class LoginUserInputDto implements ILoginUserInputDto {
    /** user name */
    username!: string;
    /** password */
    password!: string;

    constructor(data?: ILoginUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LoginUserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginUserInputDto {
    /** user name */
    username: string;
    /** password */
    password: string;
}

export class TokenInfoDto implements ITokenInfoDto {
    /** token */
    token!: string;
    /** expires in (seconds) */
    expiresIn!: number;

    constructor(data?: ITokenInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.token = data["token"];
            this.expiresIn = data["expiresIn"];
        }
    }

    static fromJS(data: any): TokenInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TokenInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["expiresIn"] = this.expiresIn;
        return data; 
    }
}

export interface ITokenInfoDto {
    /** token */
    token: string;
    /** expires in (seconds) */
    expiresIn: number;
}

export class RefreshTokenDto implements IRefreshTokenDto {
    /** token */
    token!: string;

    constructor(data?: IRefreshTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.token = data["token"];
        }
    }

    static fromJS(data: any): RefreshTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }
}

export interface IRefreshTokenDto {
    /** token */
    token: string;
}

export class RegisterUserInputDto implements IRegisterUserInputDto {
    username!: string;
    password!: string;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    email!: string;

    constructor(data?: IRegisterUserInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.password = data["password"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): RegisterUserInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data; 
    }
}

export interface IRegisterUserInputDto {
    username: string;
    password: string;
    firstName: string;
    middleName: string;
    lastName: string;
    email: string;
}

export class GetProfileResultDto implements IGetProfileResultDto {
    username!: string;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    email!: string;
    imageSrc!: string;

    constructor(data?: IGetProfileResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"];
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.imageSrc = data["imageSrc"];
        }
    }

    static fromJS(data: any): GetProfileResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfileResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["imageSrc"] = this.imageSrc;
        return data; 
    }
}

export interface IGetProfileResultDto {
    username: string;
    firstName: string;
    middleName: string;
    lastName: string;
    email: string;
    imageSrc: string;
}

export class UpdateProfileInputDto implements IUpdateProfileInputDto {
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    password!: string | undefined;

    constructor(data?: IUpdateProfileInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.middleName = data["middleName"];
            this.lastName = data["lastName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): UpdateProfileInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        return data; 
    }
}

export interface IUpdateProfileInputDto {
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    password: string | undefined;
}

export class FindAllRolesDetailDto implements IFindAllRolesDetailDto {
    /** role id */
    _id!: string;
    /** role name */
    name!: string;
    /** is default */
    isDefault!: boolean;
    /** permissions */
    permissions!: string[];
    /** created by */
    createdBy!: string;
    /** created at */
    createdAt!: moment.Moment;
    /** last modified by */
    lastModifiedBy!: string | undefined;
    /** last modified at */
    lastModifiedAt!: moment.Moment | undefined;

    constructor(data?: IFindAllRolesDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissions = [];
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.name = data["name"];
            this.isDefault = data["isDefault"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.createdBy = data["createdBy"];
            this.createdAt = data["createdAt"] ? moment(data["createdAt"].toString()) : <any>undefined;
            this.lastModifiedBy = data["lastModifiedBy"];
            this.lastModifiedAt = data["lastModifiedAt"] ? moment(data["lastModifiedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FindAllRolesDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindAllRolesDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["createdBy"] = this.createdBy;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedAt"] = this.lastModifiedAt ? this.lastModifiedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IFindAllRolesDetailDto {
    /** role id */
    _id: string;
    /** role name */
    name: string;
    /** is default */
    isDefault: boolean;
    /** permissions */
    permissions: string[];
    /** created by */
    createdBy: string;
    /** created at */
    createdAt: moment.Moment;
    /** last modified by */
    lastModifiedBy: string | undefined;
    /** last modified at */
    lastModifiedAt: moment.Moment | undefined;
}

export class FindAllRolesResultDto implements IFindAllRolesResultDto {
    /** data of roles */
    data!: FindAllRolesDetailDto[];
    /** total number of roles */
    total!: number;

    constructor(data?: IFindAllRolesResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(FindAllRolesDetailDto.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): FindAllRolesResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindAllRolesResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface IFindAllRolesResultDto {
    /** data of roles */
    data: FindAllRolesDetailDto[];
    /** total number of roles */
    total: number;
}

export class CreateRoleInputDto implements ICreateRoleInputDto {
    /** role name */
    name!: string;
    /** is default */
    isDefault!: boolean;
    /** permissions */
    permissions!: any[];

    constructor(data?: ICreateRoleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissions = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isDefault = data["isDefault"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }
}

export interface ICreateRoleInputDto {
    /** role name */
    name: string;
    /** is default */
    isDefault: boolean;
    /** permissions */
    permissions: any[];
}

export class UpdateRoleInputDto implements IUpdateRoleInputDto {
    /** role id */
    _id!: string;
    /** role name */
    name!: string;
    /** permissions */
    permissions!: any[];
    /** is default */
    isDefault!: boolean;

    constructor(data?: IUpdateRoleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissions = [];
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.name = data["name"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateRoleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["name"] = this.name;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IUpdateRoleInputDto {
    /** role id */
    _id: string;
    /** role name */
    name: string;
    /** permissions */
    permissions: any[];
    /** is default */
    isDefault: boolean;
}

export class DeleteRoleDto implements IDeleteRoleDto {
    /** role id */
    id!: string;

    constructor(data?: IDeleteRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DeleteRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeleteRoleDto {
    /** role id */
    id: string;
}

export class GetLanguageResultDto implements IGetLanguageResultDto {
    /** get language result */
    result!: any;

    constructor(data?: IGetLanguageResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = {};
        }
    }

    init(data?: any) {
        if (data) {
            if (data["result"]) {
                this.result = {};
                for (let key in data["result"]) {
                    if (data["result"].hasOwnProperty(key))
                        this.result[key] = data["result"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetLanguageResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.result) {
            data["result"] = {};
            for (let key in this.result) {
                if (this.result.hasOwnProperty(key))
                    data["result"][key] = this.result[key];
            }
        }
        return data; 
    }
}

export interface IGetLanguageResultDto {
    /** get language result */
    result: any;
}

export class CreateCompanyInputDto implements ICreateCompanyInputDto {
    /** companyname */
    companyname!: string;
    /** telephone */
    telephone!: string;
    /** streetline1 */
    streetline1!: string;
    /** streetline2 */
    streetline2!: string;
    /** city */
    city!: string;
    /** state */
    state!: string;
    /** zipcode */
    zipcode!: string;
    /** country */
    country!: string;
    /** logo */
    logo!: string;
    /** facebookurl */
    facebookurl!: string;
    /** twitterurl */
    twitterurl!: string;
    /** googleplusurl */
    googleplusurl!: string;
    /** linkedidurl */
    linkedidurl!: string;

    constructor(data?: ICreateCompanyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyname = data["companyname"];
            this.telephone = data["telephone"];
            this.streetline1 = data["streetline1"];
            this.streetline2 = data["streetline2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipcode = data["zipcode"];
            this.country = data["country"];
            this.logo = data["logo"];
            this.facebookurl = data["facebookurl"];
            this.twitterurl = data["twitterurl"];
            this.googleplusurl = data["googleplusurl"];
            this.linkedidurl = data["linkedidurl"];
        }
    }

    static fromJS(data: any): CreateCompanyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyname"] = this.companyname;
        data["telephone"] = this.telephone;
        data["streetline1"] = this.streetline1;
        data["streetline2"] = this.streetline2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipcode"] = this.zipcode;
        data["country"] = this.country;
        data["logo"] = this.logo;
        data["facebookurl"] = this.facebookurl;
        data["twitterurl"] = this.twitterurl;
        data["googleplusurl"] = this.googleplusurl;
        data["linkedidurl"] = this.linkedidurl;
        return data; 
    }
}

export interface ICreateCompanyInputDto {
    /** companyname */
    companyname: string;
    /** telephone */
    telephone: string;
    /** streetline1 */
    streetline1: string;
    /** streetline2 */
    streetline2: string;
    /** city */
    city: string;
    /** state */
    state: string;
    /** zipcode */
    zipcode: string;
    /** country */
    country: string;
    /** logo */
    logo: string;
    /** facebookurl */
    facebookurl: string;
    /** twitterurl */
    twitterurl: string;
    /** googleplusurl */
    googleplusurl: string;
    /** linkedidurl */
    linkedidurl: string;
}

export class UpdateCompanyInputDto implements IUpdateCompanyInputDto {
    /** companyname */
    companyname!: string;
    /** telephone */
    telephone!: string;
    /** streetline1 */
    streetline1!: string;
    /** streetline2 */
    streetline2!: string;
    /** city */
    city!: string;
    /** state */
    state!: string;
    /** zipcode */
    zipcode!: string;
    /** country */
    country!: string;
    /** logo */
    logo!: string;
    /** facebookurl */
    facebookurl!: string;
    /** twitterurl */
    twitterurl!: string;
    /** googleplusurl */
    googleplusurl!: string;
    /** linkedidurl */
    linkedidurl!: string;

    constructor(data?: IUpdateCompanyInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyname = data["companyname"];
            this.telephone = data["telephone"];
            this.streetline1 = data["streetline1"];
            this.streetline2 = data["streetline2"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipcode = data["zipcode"];
            this.country = data["country"];
            this.logo = data["logo"];
            this.facebookurl = data["facebookurl"];
            this.twitterurl = data["twitterurl"];
            this.googleplusurl = data["googleplusurl"];
            this.linkedidurl = data["linkedidurl"];
        }
    }

    static fromJS(data: any): UpdateCompanyInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyname"] = this.companyname;
        data["telephone"] = this.telephone;
        data["streetline1"] = this.streetline1;
        data["streetline2"] = this.streetline2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipcode"] = this.zipcode;
        data["country"] = this.country;
        data["logo"] = this.logo;
        data["facebookurl"] = this.facebookurl;
        data["twitterurl"] = this.twitterurl;
        data["googleplusurl"] = this.googleplusurl;
        data["linkedidurl"] = this.linkedidurl;
        return data; 
    }
}

export interface IUpdateCompanyInputDto {
    /** companyname */
    companyname: string;
    /** telephone */
    telephone: string;
    /** streetline1 */
    streetline1: string;
    /** streetline2 */
    streetline2: string;
    /** city */
    city: string;
    /** state */
    state: string;
    /** zipcode */
    zipcode: string;
    /** country */
    country: string;
    /** logo */
    logo: string;
    /** facebookurl */
    facebookurl: string;
    /** twitterurl */
    twitterurl: string;
    /** googleplusurl */
    googleplusurl: string;
    /** linkedidurl */
    linkedidurl: string;
}

export class GetUploadedImagesDetailDto implements IGetUploadedImagesDetailDto {
    /** image id */
    _id!: string;
    /** hyperlink */
    hyperlink!: string;
    /** file name */
    filename!: string;

    constructor(data?: IGetUploadedImagesDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.hyperlink = data["hyperlink"];
            this.filename = data["filename"];
        }
    }

    static fromJS(data: any): GetUploadedImagesDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUploadedImagesDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["hyperlink"] = this.hyperlink;
        data["filename"] = this.filename;
        return data; 
    }
}

export interface IGetUploadedImagesDetailDto {
    /** image id */
    _id: string;
    /** hyperlink */
    hyperlink: string;
    /** file name */
    filename: string;
}

export class GetUploadedImagesResultDto implements IGetUploadedImagesResultDto {
    /** get all uploaded images info */
    result!: GetUploadedImagesDetailDto[];
    /** all albums */
    albums!: string[];

    constructor(data?: IGetUploadedImagesResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
            this.albums = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["result"] && data["result"].constructor === Array) {
                this.result = [];
                for (let item of data["result"])
                    this.result.push(GetUploadedImagesDetailDto.fromJS(item));
            }
            if (data["albums"] && data["albums"].constructor === Array) {
                this.albums = [];
                for (let item of data["albums"])
                    this.albums.push(item);
            }
        }
    }

    static fromJS(data: any): GetUploadedImagesResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUploadedImagesResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.result && this.result.constructor === Array) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        if (this.albums && this.albums.constructor === Array) {
            data["albums"] = [];
            for (let item of this.albums)
                data["albums"].push(item);
        }
        return data; 
    }
}

export interface IGetUploadedImagesResultDto {
    /** get all uploaded images info */
    result: GetUploadedImagesDetailDto[];
    /** all albums */
    albums: string[];
}

export class GetAlbumsDetailDto implements IGetAlbumsDetailDto {
    /** image id */
    _id!: string;
    /** file name */
    filename!: string;
    /** hyperlink */
    hyperlink!: string;

    constructor(data?: IGetAlbumsDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.filename = data["filename"];
            this.hyperlink = data["hyperlink"];
        }
    }

    static fromJS(data: any): GetAlbumsDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAlbumsDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["filename"] = this.filename;
        data["hyperlink"] = this.hyperlink;
        return data; 
    }
}

export interface IGetAlbumsDetailDto {
    /** image id */
    _id: string;
    /** file name */
    filename: string;
    /** hyperlink */
    hyperlink: string;
}

export class GetAlbumImagesResultDto implements IGetAlbumImagesResultDto {
    /** all images of an album */
    data!: GetAlbumsDetailDto[];

    constructor(data?: IGetAlbumImagesResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(GetAlbumsDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAlbumImagesResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAlbumImagesResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAlbumImagesResultDto {
    /** all images of an album */
    data: GetAlbumsDetailDto[];
}

export class UpdateFilenameDto implements IUpdateFilenameDto {
    /** image id */
    imageId!: string;
    /** new filename */
    newName!: string;

    constructor(data?: IUpdateFilenameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.imageId = data["imageId"];
            this.newName = data["newName"];
        }
    }

    static fromJS(data: any): UpdateFilenameDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFilenameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageId"] = this.imageId;
        data["newName"] = this.newName;
        return data; 
    }
}

export interface IUpdateFilenameDto {
    /** image id */
    imageId: string;
    /** new filename */
    newName: string;
}

export class CreateAlbumDto implements ICreateAlbumDto {
    /** album name */
    albumName!: string;

    constructor(data?: ICreateAlbumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.albumName = data["albumName"];
        }
    }

    static fromJS(data: any): CreateAlbumDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAlbumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["albumName"] = this.albumName;
        return data; 
    }
}

export interface ICreateAlbumDto {
    /** album name */
    albumName: string;
}

export class CreateBlogInputDto implements ICreateBlogInputDto {
    /** title */
    title!: string;
    /** subtitle */
    subtitle!: string;
    /** author */
    author!: string;
    /** tags */
    tags!: any[];
    /** content */
    content!: string;
    /** imageSrc */
    imageSrc!: string;
    /** viewCount */
    viewCount!: number;
    /** postRating */
    postRating!: number;
    /** postRating */
    previewContent!: string;

    constructor(data?: ICreateBlogInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tags = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.subtitle = data["subtitle"];
            this.author = data["author"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(item);
            }
            this.content = data["content"];
            this.imageSrc = data["imageSrc"];
            this.viewCount = data["viewCount"];
            this.postRating = data["postRating"];
            this.previewContent = data["previewContent"];
        }
    }

    static fromJS(data: any): CreateBlogInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBlogInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["subtitle"] = this.subtitle;
        data["author"] = this.author;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["content"] = this.content;
        data["imageSrc"] = this.imageSrc;
        data["viewCount"] = this.viewCount;
        data["postRating"] = this.postRating;
        data["previewContent"] = this.previewContent;
        return data; 
    }
}

export interface ICreateBlogInputDto {
    /** title */
    title: string;
    /** subtitle */
    subtitle: string;
    /** author */
    author: string;
    /** tags */
    tags: any[];
    /** content */
    content: string;
    /** imageSrc */
    imageSrc: string;
    /** viewCount */
    viewCount: number;
    /** postRating */
    postRating: number;
    /** postRating */
    previewContent: string;
}

export class UpdateBlogDetailDto implements IUpdateBlogDetailDto {
    /** title */
    title!: string;
    /** subtitle */
    subtitle!: string;
    /** author */
    author!: string;
    /** tags */
    tags!: any[];
    /** content */
    content!: string;
    /** imageSrc */
    imageSrc!: string;
    /** viewCount */
    viewCount!: number;
    /** postRating */
    postRating!: number;
    /** postRating */
    previewContent!: string;

    constructor(data?: IUpdateBlogDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tags = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.subtitle = data["subtitle"];
            this.author = data["author"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(item);
            }
            this.content = data["content"];
            this.imageSrc = data["imageSrc"];
            this.viewCount = data["viewCount"];
            this.postRating = data["postRating"];
            this.previewContent = data["previewContent"];
        }
    }

    static fromJS(data: any): UpdateBlogDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBlogDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["subtitle"] = this.subtitle;
        data["author"] = this.author;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["content"] = this.content;
        data["imageSrc"] = this.imageSrc;
        data["viewCount"] = this.viewCount;
        data["postRating"] = this.postRating;
        data["previewContent"] = this.previewContent;
        return data; 
    }
}

export interface IUpdateBlogDetailDto {
    /** title */
    title: string;
    /** subtitle */
    subtitle: string;
    /** author */
    author: string;
    /** tags */
    tags: any[];
    /** content */
    content: string;
    /** imageSrc */
    imageSrc: string;
    /** viewCount */
    viewCount: number;
    /** postRating */
    postRating: number;
    /** postRating */
    previewContent: string;
}

export class FindBlogDetailDto implements IFindBlogDetailDto {
    /** title */
    title!: string;
    /** subtitle */
    subtitle!: string;
    /** author */
    author!: string;
    /** tags */
    tags!: any[];
    /** content */
    content!: string;
    /** imageSrc */
    imageSrc!: string;
    /** viewCount */
    viewCount!: number;
    /** postRating */
    postRating!: number;
    /** postId */
    _id!: string;
    /** deactivation status */
    deactivate!: boolean;

    constructor(data?: IFindBlogDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tags = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.subtitle = data["subtitle"];
            this.author = data["author"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(item);
            }
            this.content = data["content"];
            this.imageSrc = data["imageSrc"];
            this.viewCount = data["viewCount"];
            this.postRating = data["postRating"];
            this._id = data["_id"];
            this.deactivate = data["deactivate"];
        }
    }

    static fromJS(data: any): FindBlogDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindBlogDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["subtitle"] = this.subtitle;
        data["author"] = this.author;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["content"] = this.content;
        data["imageSrc"] = this.imageSrc;
        data["viewCount"] = this.viewCount;
        data["postRating"] = this.postRating;
        data["_id"] = this._id;
        data["deactivate"] = this.deactivate;
        return data; 
    }
}

export interface IFindBlogDetailDto {
    /** title */
    title: string;
    /** subtitle */
    subtitle: string;
    /** author */
    author: string;
    /** tags */
    tags: any[];
    /** content */
    content: string;
    /** imageSrc */
    imageSrc: string;
    /** viewCount */
    viewCount: number;
    /** postRating */
    postRating: number;
    /** postId */
    _id: string;
    /** deactivation status */
    deactivate: boolean;
}

export class FindAllBlogPostsDto implements IFindAllBlogPostsDto {
    /** Arrays of FindBlogDetailDto */
    data!: FindBlogDetailDto[];

    constructor(data?: IFindAllBlogPostsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(FindBlogDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FindAllBlogPostsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindAllBlogPostsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFindAllBlogPostsDto {
    /** Arrays of FindBlogDetailDto */
    data: FindBlogDetailDto[];
}

export class SearchInputDto implements ISearchInputDto {
    /** searchInput */
    searchInput!: string;

    constructor(data?: ISearchInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.searchInput = data["searchInput"];
        }
    }

    static fromJS(data: any): SearchInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchInput"] = this.searchInput;
        return data; 
    }
}

export interface ISearchInputDto {
    /** searchInput */
    searchInput: string;
}

export class DateRangeInputDto implements IDateRangeInputDto {
    /** DateRangeInputDto */
    dateRangeInput!: any[];

    constructor(data?: IDateRangeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dateRangeInput = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["dateRangeInput"] && data["dateRangeInput"].constructor === Array) {
                this.dateRangeInput = [];
                for (let item of data["dateRangeInput"])
                    this.dateRangeInput.push(item);
            }
        }
    }

    static fromJS(data: any): DateRangeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dateRangeInput && this.dateRangeInput.constructor === Array) {
            data["dateRangeInput"] = [];
            for (let item of this.dateRangeInput)
                data["dateRangeInput"].push(item);
        }
        return data; 
    }
}

export interface IDateRangeInputDto {
    /** DateRangeInputDto */
    dateRangeInput: any[];
}

export class FindTeachersDetailDto implements IFindTeachersDetailDto {
    /** teacher id */
    _id!: string;
    /** teacher first name */
    firstName!: string;
    /** teacher last name */
    lastName!: string;
    /** teacher full name */
    fullName!: string;
    /** teacher email */
    email!: string;
    /** teacher phone number */
    phone!: string;
    dob!: any;
    /** subject that the teacher teach */
    subject!: string;
    /** is the teacher active ? */
    isActive!: boolean;
    /** description */
    description!: string;
    /** profile picture hyperlink */
    imgSrc!: string;

    constructor(data?: IFindTeachersDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dob = {};
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.fullName = data["fullName"];
            this.email = data["email"];
            this.phone = data["phone"];
            if (data["dob"]) {
                this.dob = {};
                for (let key in data["dob"]) {
                    if (data["dob"].hasOwnProperty(key))
                        this.dob[key] = data["dob"][key];
                }
            }
            this.subject = data["subject"];
            this.isActive = data["isActive"];
            this.description = data["description"];
            this.imgSrc = data["imgSrc"];
        }
    }

    static fromJS(data: any): FindTeachersDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindTeachersDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        if (this.dob) {
            data["dob"] = {};
            for (let key in this.dob) {
                if (this.dob.hasOwnProperty(key))
                    data["dob"][key] = this.dob[key];
            }
        }
        data["subject"] = this.subject;
        data["isActive"] = this.isActive;
        data["description"] = this.description;
        data["imgSrc"] = this.imgSrc;
        return data; 
    }
}

export interface IFindTeachersDetailDto {
    /** teacher id */
    _id: string;
    /** teacher first name */
    firstName: string;
    /** teacher last name */
    lastName: string;
    /** teacher full name */
    fullName: string;
    /** teacher email */
    email: string;
    /** teacher phone number */
    phone: string;
    dob: any;
    /** subject that the teacher teach */
    subject: string;
    /** is the teacher active ? */
    isActive: boolean;
    /** description */
    description: string;
    /** profile picture hyperlink */
    imgSrc: string;
}

export class FindTeachersResultDto implements IFindTeachersResultDto {
    /** all the result */
    data!: FindTeachersDetailDto[];
    /** total record */
    total!: number;

    constructor(data?: IFindTeachersResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(FindTeachersDetailDto.fromJS(item));
            }
            this.total = data["total"];
        }
    }

    static fromJS(data: any): FindTeachersResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindTeachersResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface IFindTeachersResultDto {
    /** all the result */
    data: FindTeachersDetailDto[];
    /** total record */
    total: number;
}

export class CreateTeacherInputDto implements ICreateTeacherInputDto {
    /** first name */
    firstName!: string;
    /** last name */
    lastName!: string;
    /** email */
    email!: string;
    /** phone number */
    phone!: string;
    dob!: any;
    /** subject */
    subject!: string;
    /** description */
    description!: string;

    constructor(data?: ICreateTeacherInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dob = {};
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.phone = data["phone"];
            if (data["dob"]) {
                this.dob = {};
                for (let key in data["dob"]) {
                    if (data["dob"].hasOwnProperty(key))
                        this.dob[key] = data["dob"][key];
                }
            }
            this.subject = data["subject"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): CreateTeacherInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTeacherInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        if (this.dob) {
            data["dob"] = {};
            for (let key in this.dob) {
                if (this.dob.hasOwnProperty(key))
                    data["dob"][key] = this.dob[key];
            }
        }
        data["subject"] = this.subject;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateTeacherInputDto {
    /** first name */
    firstName: string;
    /** last name */
    lastName: string;
    /** email */
    email: string;
    /** phone number */
    phone: string;
    dob: any;
    /** subject */
    subject: string;
    /** description */
    description: string;
}

export class UpdateTeacherInfoDto implements IUpdateTeacherInfoDto {
    /** teacher id */
    _id!: string;
    /** first name */
    firstName!: string;
    /** last name */
    lastName!: string;
    /** email */
    email!: string;
    /** phone number */
    phone!: string;
    dob!: any;
    /** subject */
    subject!: string;
    /** description */
    description!: string;

    constructor(data?: IUpdateTeacherInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dob = {};
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.phone = data["phone"];
            if (data["dob"]) {
                this.dob = {};
                for (let key in data["dob"]) {
                    if (data["dob"].hasOwnProperty(key))
                        this.dob[key] = data["dob"][key];
                }
            }
            this.subject = data["subject"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): UpdateTeacherInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTeacherInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        if (this.dob) {
            data["dob"] = {};
            for (let key in this.dob) {
                if (this.dob.hasOwnProperty(key))
                    data["dob"][key] = this.dob[key];
            }
        }
        data["subject"] = this.subject;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateTeacherInfoDto {
    /** teacher id */
    _id: string;
    /** first name */
    firstName: string;
    /** last name */
    lastName: string;
    /** email */
    email: string;
    /** phone number */
    phone: string;
    dob: any;
    /** subject */
    subject: string;
    /** description */
    description: string;
}

export class FindMenuConfigDto implements IFindMenuConfigDto {
    /** id */
    _id!: string;
    /** order */
    order!: number;
    /** hyperlink */
    hyperlink!: string;
    /** submenu */
    submenu!: any[];
    /** name */
    name!: string;
    /** parentid */
    parentid!: any[];
    /** parentIdData */
    parentIdData!: any[];
    /** activationStatus */
    activationStatus!: boolean;

    constructor(data?: IFindMenuConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.submenu = [];
            this.parentid = [];
            this.parentIdData = [];
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.order = data["order"];
            this.hyperlink = data["hyperlink"];
            if (data["submenu"] && data["submenu"].constructor === Array) {
                this.submenu = [];
                for (let item of data["submenu"])
                    this.submenu.push(item);
            }
            this.name = data["name"];
            if (data["parentid"] && data["parentid"].constructor === Array) {
                this.parentid = [];
                for (let item of data["parentid"])
                    this.parentid.push(item);
            }
            if (data["parentIdData"] && data["parentIdData"].constructor === Array) {
                this.parentIdData = [];
                for (let item of data["parentIdData"])
                    this.parentIdData.push(item);
            }
            this.activationStatus = data["activationStatus"];
        }
    }

    static fromJS(data: any): FindMenuConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindMenuConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["order"] = this.order;
        data["hyperlink"] = this.hyperlink;
        if (this.submenu && this.submenu.constructor === Array) {
            data["submenu"] = [];
            for (let item of this.submenu)
                data["submenu"].push(item);
        }
        data["name"] = this.name;
        if (this.parentid && this.parentid.constructor === Array) {
            data["parentid"] = [];
            for (let item of this.parentid)
                data["parentid"].push(item);
        }
        if (this.parentIdData && this.parentIdData.constructor === Array) {
            data["parentIdData"] = [];
            for (let item of this.parentIdData)
                data["parentIdData"].push(item);
        }
        data["activationStatus"] = this.activationStatus;
        return data; 
    }
}

export interface IFindMenuConfigDto {
    /** id */
    _id: string;
    /** order */
    order: number;
    /** hyperlink */
    hyperlink: string;
    /** submenu */
    submenu: any[];
    /** name */
    name: string;
    /** parentid */
    parentid: any[];
    /** parentIdData */
    parentIdData: any[];
    /** activationStatus */
    activationStatus: boolean;
}

export class FindAllMenuConfigDto implements IFindAllMenuConfigDto {
    /** Arrays of FindBlogDetailDto */
    allMenuConfigData!: FindMenuConfigDto[];

    constructor(data?: IFindAllMenuConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.allMenuConfigData = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allMenuConfigData"] && data["allMenuConfigData"].constructor === Array) {
                this.allMenuConfigData = [];
                for (let item of data["allMenuConfigData"])
                    this.allMenuConfigData.push(FindMenuConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FindAllMenuConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindAllMenuConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allMenuConfigData && this.allMenuConfigData.constructor === Array) {
            data["allMenuConfigData"] = [];
            for (let item of this.allMenuConfigData)
                data["allMenuConfigData"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFindAllMenuConfigDto {
    /** Arrays of FindBlogDetailDto */
    allMenuConfigData: FindMenuConfigDto[];
}

export class FindParentIdMenuConfigDto implements IFindParentIdMenuConfigDto {
    /** _id */
    _id!: string;
    /** name */
    name!: string;

    constructor(data?: IFindParentIdMenuConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._id = data["_id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): FindParentIdMenuConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindParentIdMenuConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_id"] = this._id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IFindParentIdMenuConfigDto {
    /** _id */
    _id: string;
    /** name */
    name: string;
}

export class FindAllParentIdMenuConfigDto implements IFindAllParentIdMenuConfigDto {
    /** list of parent id */
    parentIdData!: FindParentIdMenuConfigDto[];

    constructor(data?: IFindAllParentIdMenuConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parentIdData = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (data["parentIdData"] && data["parentIdData"].constructor === Array) {
                this.parentIdData = [];
                for (let item of data["parentIdData"])
                    this.parentIdData.push(FindParentIdMenuConfigDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FindAllParentIdMenuConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindAllParentIdMenuConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.parentIdData && this.parentIdData.constructor === Array) {
            data["parentIdData"] = [];
            for (let item of this.parentIdData)
                data["parentIdData"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFindAllParentIdMenuConfigDto {
    /** list of parent id */
    parentIdData: FindParentIdMenuConfigDto[];
}

export class CreateMenuConfigDto implements ICreateMenuConfigDto {
    /** order */
    order!: number;
    /** hyperlink */
    hyperlink!: string;
    /** submenu */
    submenu!: any[];
    /** name */
    name!: string;
    /** parentid */
    parentid!: any[];

    constructor(data?: ICreateMenuConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.submenu = [];
            this.parentid = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.order = data["order"];
            this.hyperlink = data["hyperlink"];
            if (data["submenu"] && data["submenu"].constructor === Array) {
                this.submenu = [];
                for (let item of data["submenu"])
                    this.submenu.push(item);
            }
            this.name = data["name"];
            if (data["parentid"] && data["parentid"].constructor === Array) {
                this.parentid = [];
                for (let item of data["parentid"])
                    this.parentid.push(item);
            }
        }
    }

    static fromJS(data: any): CreateMenuConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMenuConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order;
        data["hyperlink"] = this.hyperlink;
        if (this.submenu && this.submenu.constructor === Array) {
            data["submenu"] = [];
            for (let item of this.submenu)
                data["submenu"].push(item);
        }
        data["name"] = this.name;
        if (this.parentid && this.parentid.constructor === Array) {
            data["parentid"] = [];
            for (let item of this.parentid)
                data["parentid"].push(item);
        }
        return data; 
    }
}

export interface ICreateMenuConfigDto {
    /** order */
    order: number;
    /** hyperlink */
    hyperlink: string;
    /** submenu */
    submenu: any[];
    /** name */
    name: string;
    /** parentid */
    parentid: any[];
}

export class UpdateMenuConfigDto implements IUpdateMenuConfigDto {
    /** order */
    order!: number;
    /** hyperlink */
    hyperlink!: string;
    /** submenu */
    submenu!: any[];
    /** name */
    name!: string;
    /** parentid */
    parentid!: any[];

    constructor(data?: IUpdateMenuConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.submenu = [];
            this.parentid = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.order = data["order"];
            this.hyperlink = data["hyperlink"];
            if (data["submenu"] && data["submenu"].constructor === Array) {
                this.submenu = [];
                for (let item of data["submenu"])
                    this.submenu.push(item);
            }
            this.name = data["name"];
            if (data["parentid"] && data["parentid"].constructor === Array) {
                this.parentid = [];
                for (let item of data["parentid"])
                    this.parentid.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateMenuConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMenuConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order;
        data["hyperlink"] = this.hyperlink;
        if (this.submenu && this.submenu.constructor === Array) {
            data["submenu"] = [];
            for (let item of this.submenu)
                data["submenu"].push(item);
        }
        data["name"] = this.name;
        if (this.parentid && this.parentid.constructor === Array) {
            data["parentid"] = [];
            for (let item of this.parentid)
                data["parentid"].push(item);
        }
        return data; 
    }
}

export interface IUpdateMenuConfigDto {
    /** order */
    order: number;
    /** hyperlink */
    hyperlink: string;
    /** submenu */
    submenu: any[];
    /** name */
    name: string;
    /** parentid */
    parentid: any[];
}

export class GetAttendanceRecordInputDto implements IGetAttendanceRecordInputDto {
    /** student code */
    studentCode!: string;
    /** recaptcha response */
    captchaResponse!: string;

    constructor(data?: IGetAttendanceRecordInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.studentCode = data["studentCode"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): GetAttendanceRecordInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAttendanceRecordInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentCode"] = this.studentCode;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IGetAttendanceRecordInputDto {
    /** student code */
    studentCode: string;
    /** recaptcha response */
    captchaResponse: string;
}

export class RegisterInputDto implements IRegisterInputDto {
    /** student name */
    studentName!: string;
    /** student phone number */
    studentPhoneNumber!: string;
    /** student email */
    studentEmail!: string;
    studentBirthday!: any;
    /** student address */
    studentAddress!: string;
    /** phone number of parents */
    parentPhoneNumber!: string;
    /** register subjects */
    registerSubjects!: string[];
    /** note */
    note!: string | undefined;

    constructor(data?: IRegisterInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.studentBirthday = {};
            this.registerSubjects = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.studentName = data["studentName"];
            this.studentPhoneNumber = data["studentPhoneNumber"];
            this.studentEmail = data["studentEmail"];
            if (data["studentBirthday"]) {
                this.studentBirthday = {};
                for (let key in data["studentBirthday"]) {
                    if (data["studentBirthday"].hasOwnProperty(key))
                        this.studentBirthday[key] = data["studentBirthday"][key];
                }
            }
            this.studentAddress = data["studentAddress"];
            this.parentPhoneNumber = data["parentPhoneNumber"];
            if (data["registerSubjects"] && data["registerSubjects"].constructor === Array) {
                this.registerSubjects = [];
                for (let item of data["registerSubjects"])
                    this.registerSubjects.push(item);
            }
            this.note = data["note"];
        }
    }

    static fromJS(data: any): RegisterInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentName"] = this.studentName;
        data["studentPhoneNumber"] = this.studentPhoneNumber;
        data["studentEmail"] = this.studentEmail;
        if (this.studentBirthday) {
            data["studentBirthday"] = {};
            for (let key in this.studentBirthday) {
                if (this.studentBirthday.hasOwnProperty(key))
                    data["studentBirthday"][key] = this.studentBirthday[key];
            }
        }
        data["studentAddress"] = this.studentAddress;
        data["parentPhoneNumber"] = this.parentPhoneNumber;
        if (this.registerSubjects && this.registerSubjects.constructor === Array) {
            data["registerSubjects"] = [];
            for (let item of this.registerSubjects)
                data["registerSubjects"].push(item);
        }
        data["note"] = this.note;
        return data; 
    }
}

export interface IRegisterInputDto {
    /** student name */
    studentName: string;
    /** student phone number */
    studentPhoneNumber: string;
    /** student email */
    studentEmail: string;
    studentBirthday: any;
    /** student address */
    studentAddress: string;
    /** phone number of parents */
    parentPhoneNumber: string;
    /** register subjects */
    registerSubjects: string[];
    /** note */
    note: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}